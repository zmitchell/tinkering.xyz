<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Bringing macros to Python by abusing type annotations &middot; Tinkering</title>
  <meta name="description" content="By playing with the Python AST we can add functionality with making the user write any extra code. You may use this power for good or evil." />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#aa0000">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="alternate" type="application/atom+xml" title="RSS" href="https://tinkering.xyz/ atom.xml">

  <style>
    *,:after,:before{box-sizing:border-box}:root{--color-bg: #f2f2f2;--color-dark: #222222;--color-mid: #ced4da;--color-light: #dee2e6;--color-accent: #089ce7;--text-width: 70ch;--size-base: clamp(1rem, 0.96rem + 0.22vw, 1.125rem);--size-step-0: clamp(0.8125rem, 0.79rem + 0.11vw, 0.875rem);--size-step-1: clamp(1.1875rem, 1.12rem + 0.33vw, 1.375rem);--size-step-2: clamp(1.4375rem, 1.33rem + 0.54vw, 1.75rem);--size-step-3: clamp(1.6875rem, 1.51rem + 0.87vw, 2.1875rem);--size-step-4: clamp(2.0625rem, 1.85rem + 1.09vw, 2.6875rem);--font-face: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
		"Segoe UI Symbol"}body{background:var(--color-bg);color:var(--color-dark);font-size:var(--size-base);font-family:var(--font-face);line-height:1.6;text-rendering:optimizeSpeed}h1{font-size:var(--size-step-3)}h2{font-size:var(--size-step-2)}h3{font-size:var(--size-step-1);line-height:1.2}main{margin:auto;max-width:var(--text-width);padding:0.8rem}@media (max-width: var(--text-width)){.homepage-list a{width:100%}}a{color:currentColor;text-decoration-line:underline;text-decoration-color:var(--color-accent);text-decoration-thickness:0.15em;text-underline-offset:0.15em;text-decoration-skip-ink:none}title a{text-decoration-skip-ink:all}a:hover{text-decoration-thickness:0.3em;text-underline-offset:0.05em}blockquote{border-left-color:var(--color-accent);border-left-width:0.25em;border-left-style:solid;margin-left:0em;margin-right:0em;padding:0.5em;background-color:var(--color-mid)}td{border:1px solid var(--color-dark);padding:10px}img{height:auto;max-width:100%}.nav__link{margin-left:0;margin-right:1em}.homepage-list{display:flex;flex-direction:column;list-style:none;padding:0;margin-top:0em}.homepage-list a{text-decoration-thickness:0.05em;-webkit-text-decoration-thickness:0.05em}.pagination{display:flex;justify-content:space-between}.pagination__onlynext{justify-content:flex-end}.post{display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;margin-top:0}.post__title{margin:0;line-height:1.2em;justify-content:flex-start}.post__date{display:block;margin-top:0;margin-bottom:0.5em;font-style:italic}.post__description{margin-top:0;margin-bottom:2em}pre{overflow:scroll;padding:1rem}code{font-size:90%}code:not(pre>code){padding:.15em .25em;color:var(--color-dark);background-color:var(--color-light);border-radius:3px}

  </style>

  <meta property="og:site_name" content="Tinkering">
  <meta name="author" content="Zach Mitchell" />
  <meta property="og:title" content="Bringing macros to Python by abusing type annotations">
  <meta property="og:description" content="By playing with the Python AST we can add functionality with making the user write any extra code. You may use this power for good or evil.">
  <meta property="og:url" content="https://tinkering.xyz/abusing-type-annotations/">
  <meta property="og:image"
    content="">

  <meta property="og:type" content="article" />
  <meta property="article:published_time" content=" 2018-08-04T00:00:00+00:00" />

  
  
  

</head>


<body>
  <main id="main" role="main">

    
    <header role="banner">
      <h3 style="margin-top:0;">
        <a href="https://tinkering.xyz" title="Home">Tinkering</a>
        <br /><small>Come for the Foo, stay for the Bar</small>
      </h3>
      <nav role="navigation">
        
          <a class="nav__link" href="/">Home</a>
        
          <a class="nav__link" href="https://github.com/zmitchell">GitHub</a>
        
          <a class="nav__link" href="/about/">About</a>
        
      </nav>
    </header>
    <hr />
    

    
<article>
  <h1>Bringing macros to Python by abusing type annotations</h1>

  
  <p style="font-size:90%;">Posted on <time datetime=" 2018-08-04T00:00:00+00:00">August 04, 2018</time></p>
  

  
  <div>
    <p>Table of Contents:</p>
    <ul>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#introduction">Introduction</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#what-am-i-trying-to-build">What am I trying to build?</a>
        
        <ul>
          
          <li>
            <a href="https://tinkering.xyz/abusing-type-annotations/#what-is-a-macro">What is a macro?</a>
          </li>
          
          <li>
            <a href="https://tinkering.xyz/abusing-type-annotations/#what-s-special-about-rust-macros">What&#x27;s special about Rust macros?</a>
          </li>
          
          <li>
            <a href="https://tinkering.xyz/abusing-type-annotations/#what-do-my-macros-need-to-do">What do my macros need to do?</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#research">Research</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#abstract-syntax-trees">Abstract syntax trees</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#example-1-inrange">Example 1 - @inrange</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#example-2-notify">Example 2 - @notify</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/abusing-type-annotations/#taking-it-to-the-next-level">Taking it to the next level</a>
        
      </li>
      
    </ul>
  </div>
  

  <h1 id="introduction">Introduction</h1>
<p>The desire to bring macros to Python came from my experience with Rust's procedural macros, so we're going to talk about Rust for a second. If you'd like to skip ahead to the Python stuff, <a href="#skip">click here</a>. Rust is becoming more and more popular by the day for reasons that you've probably heard about:</p>
<ul>
<li>It's really fast.</li>
<li>It has a nice, modern type system.</li>
<li>It prevents lots of memory errors.</li>
</ul>
<p>However, my favorite feature of Rust isn't its speed, helpful error messages, etc, but rather its macro system.</p>
<p>There are two types of macros in Rust: declarative and procedural. The real heavy hitters are the procedural macros. The compiler takes your program, parses it into a data structure called an abstract syntax tree (AST), then hands it to a procedural macro. The macro can then do whatever it wants to the AST as long as it hands a valid AST back to the compiler in the end. These are great for code generation. Let's see an example.</p>
<p>Let's say I want to parse some command line arguments into this struct:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>Opt {
</span><span>    </span><span style="color:#bf616a;">debug</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>    </span><span style="color:#bf616a;">verbose</span><span>: </span><span style="color:#b48ead;">u8</span><span>,
</span><span>    </span><span style="color:#bf616a;">output</span><span>: PathBuf,
</span><span>}
</span></code></pre>
<p>There's <s>an app</s> a crate for that: <code>structopt</code>. All we have to do is sprinkle some <code>#[...]</code> things (attributes) into our struct definition. I'm not teaching you Rust right now, so don't worry about the details.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(StructOpt, Debug)]
</span><span>#[</span><span style="color:#bf616a;">structopt</span><span>(name = &quot;</span><span style="color:#a3be8c;">basic</span><span>&quot;)]
</span><span style="color:#b48ead;">struct </span><span>Opt {
</span><span>    </span><span style="color:#65737e;">// Enable debug mode
</span><span>    #[</span><span style="color:#bf616a;">structopt</span><span>(short = &quot;</span><span style="color:#a3be8c;">d</span><span>&quot;, long = &quot;</span><span style="color:#a3be8c;">debug</span><span>&quot;)]
</span><span>    </span><span style="color:#bf616a;">debug</span><span>: </span><span style="color:#b48ead;">bool</span><span>,
</span><span>
</span><span>    </span><span style="color:#65737e;">// Set verbosity
</span><span>    #[</span><span style="color:#bf616a;">structopt</span><span>(short = &quot;</span><span style="color:#a3be8c;">v</span><span>&quot;, long = &quot;</span><span style="color:#a3be8c;">verbose</span><span>&quot;, </span><span style="color:#bf616a;">parse</span><span>(from_occurrences))]
</span><span>    </span><span style="color:#bf616a;">verbose</span><span>: </span><span style="color:#b48ead;">u8</span><span>,
</span><span>
</span><span>    </span><span style="color:#65737e;">// Output file
</span><span>    #[</span><span style="color:#bf616a;">structopt</span><span>(short = &quot;</span><span style="color:#a3be8c;">o</span><span>&quot;, long = &quot;</span><span style="color:#a3be8c;">output</span><span>&quot;, </span><span style="color:#bf616a;">parse</span><span>(from_os_str))]
</span><span>    </span><span style="color:#bf616a;">output</span><span>: PathBuf,
</span><span>}
</span></code></pre>
<p>The compiler will see the macro and generate all of the code needed to parse command line arguments into the struct <code>Opt</code>.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> opt = Opt::from_args();  </span><span style="color:#65737e;">// thank you structopt!
</span><span>    println!(&quot;</span><span style="color:#d08770;">{:?}</span><span>&quot;, opt);
</span><span>}
</span></code></pre>
<p>That's pretty handy, right? All you had to do was define which arguments you were expecting, and the macro took care of the rest!</p>
<p>You can also do less useful things, like blow up your editor with error messages from The Wickerman.</p>
<p><img src="/images/not-the-bees-editor.jpg" alt="error message saying &quot;not the bees&quot; pointing to a struct field named &quot;bees&quot;" /></p>
<p>If you'd like to read about that, you can do so here: <a href="https://tinkering.xyz/introduction-to-proc-macros">link to shameless plug</a></p>
<p>So, here's the million dollar question: Can you make Rust-like macros in Python?</p>
<p><a name="skip"></a></p>
<h1 id="what-am-i-trying-to-build">What am I trying to build?</h1>
<p>Let's unpack what it means to have Rust-like macros in Python. I'll examine this with three questions:</p>
<ul>
<li>What is a macro?</li>
<li>What's special about Rust macros?</li>
<li>What do my Python macros need to do?</li>
</ul>
<h2 id="what-is-a-macro">What is a macro?</h2>
<p>Usually a macro provides a shorthand for something. In this case, a macro would be a function that takes your class definition as input, reads it, generates some code for you, and returns a new class with the generated code.</p>
<h2 id="what-s-special-about-rust-macros">What's special about Rust macros?</h2>
<p>A primitive macro system operates by simply replacing one bit of text with another i.e. replacing <code>PY_VERSION</code> with <code>3.6.5</code>. Rust's (procedural) macros operate by performing operations on the logical structure of your code (the AST). Rust's macros can be applied to struct, enum, function, and module declarations. Furthermore, macros can be applied to the members of structs/enums, like in the example above.</p>
<h2 id="what-do-my-macros-need-to-do">What do my macros need to do?</h2>
<p>I want the macros to provide a convenient alternative to something tedious. That said, this is only a proof of concept, so the problems I'm solving will be a little contrived. I'm going to keep the scope narrow and apply my macros only to class definitions. I still want to be able to configure how the macro operates on individual class/instance attributes, though.</p>
<h1 id="research">Research</h1>
<p>I set out to determine if it was even possible to do what I wanted to do. I knew that I could apply a decorator to a class, so that part was covered. The part that would be trickier is attaching information to individual class or instance attributes. Eventually something jumped out at me. Take a look:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    foo: int  </span><span style="color:#65737e;"># &lt;-- information attached to &quot;foo&quot;!
</span></code></pre>
<p>A type annotation looks like what I want to do, but what if I want to put something other than <code>int</code>, <code>str</code>, <code>List[int]</code>, etc in the annotation? I looked around and remembered that in some cases you put a string where you would normally put the annotation, like so:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    foo: &quot;</span><span style="color:#a3be8c;">MyClass</span><span>&quot;
</span></code></pre>
<p>This allows you to use types that haven't been defined yet as an annotation, like when you're defining a recursive data structure. So the type annotation doesn't have to be an actual class, it can also be a string. Well, what can go in this string? Anything, apparently!</p>
<p>If you read PEP 484 (relevent section <a href="https://www.python.org/dev/peps/pep-0484/#acceptable-type-hints">here</a>) you'll see that the type annotation can actually be any valid Python expression. The implications of that didn't really sink in at first, so we'll come back to it later.</p>
<p>At this point I realized that I could stick arbitrary information in a string and attach it to a variable. Sure, this wouldn't play well with type checkers, or really any sane use case for type annotations, but no one <em>really</em> uses type annotations, right? All the cool kids are doing it, no one will get hurt. Don't be such a square!</p>
<p>Ok, so I can store information in the annotations, but how do I read it at some later time? To the <a href="https://docs.python.org/3/reference/datamodel.html">Python data model</a>! I dove into the data model to learn about the guts of Python. I actually got my first CPython contribution from this endeavor.</p>
<p><img src="/images/cpython-pr.png" alt="a pull request changing a single letter in some documentation" /></p>
<p>I'm still waiting for my core developer invitation. Anyway, I learned that annotations are stored in the <code>__annotations__</code> attribute. The <code>__annotations__</code> attribute is a dictionary where the keys are the attribute names, and the values are the annotations. Consider the following class:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    foo: int
</span><span>    bar: &quot;</span><span style="color:#a3be8c;">anything</span><span>&quot;
</span></code></pre>
<p>The contents of <code>__annotations__</code> would look like this:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt;&gt;&gt; MyClass.__annotations__
</span><span>{
</span><span>    &#39;foo&#39;: &lt;class &#39;int&#39;&gt;,
</span><span>    &#39;bar&#39;: &#39;anything&#39;,
</span><span>}
</span></code></pre>
<p>Now I know I can store information in type annotations, and I know how to retrieve that information. All that's left is messing with abstract syntax trees.</p>
<h1 id="abstract-syntax-trees">Abstract syntax trees</h1>
<p>Parsing code into an abstract syntax tree is something that Python does when it compiles your source code into bytecode. In fact, the <code>ast</code> module contains all of the data structures, or &quot;nodes&quot;, that your Python code can be parsed into. The <a href="https://docs.python.org/3/library/ast.html">module documentation</a> doesn't do a great job of making it clear which nodes exist or what their attributes are. Instead, I recommend <a href="https://greentreesnakes.readthedocs.io/en/latest/">this page</a> if you want to see what's at your disposal. For those of you that have never seen or heard of an abstract syntax tree, I'll show you the basics by building up the AST of a small code snippet.</p>
<p>Let's start with a really basic code snippet: <code>10</code>. This is just the number 10. Exciting. To represent this you create an instance of <code>ast.Num</code>:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>num = ast.</span><span style="color:#bf616a;">Num</span><span>(</span><span style="color:#bf616a;">n</span><span>=</span><span style="color:#d08770;">10</span><span>)
</span></code></pre>
<p>What about <code>-10</code>? That's more complicated because <code>-</code> is an operator, so <code>-10</code> is <strong>not</strong> just <code>ast.Num(n=-10)</code>. Instead, it's this:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>num = ast.</span><span style="color:#bf616a;">UnaryOp</span><span>(</span><span style="color:#bf616a;">op</span><span>=ast.</span><span style="color:#bf616a;">USub</span><span>(), </span><span style="color:#bf616a;">operand</span><span>=ast.</span><span style="color:#bf616a;">Num</span><span>(</span><span style="color:#bf616a;">n</span><span>=</span><span style="color:#d08770;">10</span><span>))
</span></code></pre>
<p>What if I want to assign <code>-10</code> to a variable <code>x</code>? That's an assignment, so we'll need an <code>ast.Assign</code> node, but how do you handle <code>x</code>? Any time you reference a variable, you need an <code>ast.Name</code> node. Each <code>Name</code> has an <code>id</code>, which is the name of the variable, and a context, <code>ctx</code>, which indicates whether you're getting (<code>ast.Load()</code>) or setting (<code>ast.Store()</code>) the value of the variable. Putting all of that together, the assignment looks like this:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#65737e;"># x = -10
</span><span>num_node = ast.</span><span style="color:#bf616a;">UnaryOp</span><span>(</span><span style="color:#bf616a;">op</span><span>=ast.</span><span style="color:#bf616a;">USub</span><span>(), </span><span style="color:#bf616a;">operand</span><span>=ast.</span><span style="color:#bf616a;">Num</span><span>(</span><span style="color:#bf616a;">n</span><span>=</span><span style="color:#d08770;">10</span><span>))
</span><span>x_node = ast.</span><span style="color:#bf616a;">Name</span><span>(</span><span style="color:#bf616a;">id</span><span>=&quot;</span><span style="color:#a3be8c;">x</span><span>&quot;, </span><span style="color:#bf616a;">ctx</span><span>=ast.</span><span style="color:#bf616a;">Store</span><span>())
</span><span>assign_node = ast.</span><span style="color:#bf616a;">Assign</span><span>(</span><span style="color:#bf616a;">targets</span><span>=[x_node], </span><span style="color:#bf616a;">value</span><span>=num_node)
</span></code></pre>
<p>That's really all there is to it, so hopefully you get the idea. Building up anything more complicated than that is just a matter of putting the right nodes together. If you want to play around with this, you can also do the reverse:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt;&gt;&gt; ast.parse(&quot;x = -10&quot;)
</span><span>&lt;_ast.Module object at 0x10f5f3208&gt;
</span></code></pre>
<p>Note that any time you use <code>ast.parse</code>, the result will be a module. The <code>Assign</code> node will be in the <code>body</code> of the <code>Module</code>.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt;&gt;&gt; module = ast.parse(&quot;x = -10&quot;)
</span><span>&gt;&gt;&gt; module.body[0]
</span><span>&lt;_ast.Assign object at 0x101ad4d68&gt;
</span></code></pre>
<p>As you can see, the string representation isn't super helpful. Some libraries that provide useful tools for dealing with ASTs in Python (and printing them in more useful ways) are <a href="https://github.com/berkerpeksag/astor">astor</a> and <a href="https://github.com/asottile/astpretty">astpretty</a>. Here's the same thing using <code>astpretty</code>:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt;&gt;&gt; import ast
</span><span>&gt;&gt;&gt; from astpretty import pprint
</span><span>&gt;&gt;&gt; pprint(ast.parse(&quot;x = -10&quot;))
</span><span>Module(
</span><span>    body=[
</span><span>        Assign(
</span><span>			lineno=1,
</span><span>			col_offset=0,
</span><span>			targets=[Name(lineno=1, col_offset=0, id=&#39;x&#39;, ctx=Store())],
</span><span>			value=UnaryOp(
</span><span>				lineno=1,
</span><span>				col_offset=4,
</span><span>				op=USub(),
</span><span>				operand=Num(lineno=1, col_offset=5, n=10),
</span><span>			),
</span><span>		),
</span><span>	],
</span><span>)
</span></code></pre>
<p>Now that I have all of the pieces in place (decorators, type annotations, and ASTs), I can show you what you can do with all of this!</p>
<h1 id="example-1-inrange">Example 1 - <code>@inrange</code></h1>
<p>For my first trick, I've created a decorator, <code>@inrange</code>. If you place the annotation <code>&quot;0 &lt; foo &lt; 3&quot;</code> on a class variable named <code>foo</code>, the decorator will generate a class with a property named <code>foo</code> that only accepts values in the range (0, 3) exclusive. Consider the following class definition:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>@</span><span style="color:#bf616a;">inrange
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    var: &quot;</span><span style="color:#a3be8c;">0 &lt; var &lt; 10</span><span>&quot;
</span></code></pre>
<p>The decorator will generate a class equivalent to this:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    var: &quot;</span><span style="color:#a3be8c;">0 &lt; var &lt; 10</span><span>&quot;
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>._var = </span><span style="color:#d08770;">None
</span><span>
</span><span>    @</span><span style="color:#96b5b4;">property
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">var</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">self</span><span>._var
</span><span>
</span><span>    @var.</span><span style="color:#bf616a;">setter
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">var</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">new_value</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#d08770;">0 </span><span>&lt; new_value &lt; </span><span style="color:#d08770;">10</span><span>:
</span><span>            </span><span style="color:#bf616a;">self</span><span>._var = new_value
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            </span><span style="color:#b48ead;">raise </span><span>ValueError
</span></code></pre>
<p>Here's what it looks like in action:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt;&gt;&gt; @inrange
</span><span>... class MyClass:
</span><span>...     foo: &quot;0 &lt; foo &lt; 5&quot;
</span><span>...
</span><span>
</span><span>&gt;&gt;&gt; bar = MyClass()
</span><span>&gt;&gt;&gt; bar.foo = 1  # no problems here!
</span><span>&gt;&gt;&gt; bar.foo = 6  # oh no, greater than 5!
</span><span>Traceback (most recent call last):
</span><span>  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;
</span><span>    bar.foo = 6
</span><span>  File &quot;/Users/zmitchell/Projects/annotation-abuse/annotation_abuse/asts.py&quot;, line 1, in foo_setter
</span><span>    import ast
</span><span>ValueError: value outside of range 0 &lt; foo &lt; 5
</span></code></pre>
<p>There are some weird things here. Note that the line above the <code>ValueError</code> says <code>import ast</code>, even though I didn't import the <code>ast</code> module in the shell. I use the <code>ast</code> module to generate code, but I don't really know what that's about. The error message also says that the error occurs in <code>foo_setter</code>, even though you don't have a function called <code>foo_setter</code>. This is a result of the way that I make the properties. For a variable named <code>foo</code> I create the functions <code>foo_getter</code> and <code>foo_setter</code>, create a property with <code>property(foo_getter, foo_setter)</code>, then bind that to the attribute <code>foo</code>.</p>
<p>Here are the broad strokes of how this works, assuming you have a class named <code>MyClass</code> and you've annotated a class variable named <code>var</code>:</p>
<ul>
<li>Grab the annotation from <code>MyClass.__annotations__[&quot;var&quot;]</code>.</li>
<li>Grab the endpoints of the range from the annotation.</li>
<li>Generate ASTs for the getter and setter of <code>var</code>.</li>
<li>Compile the ASTs to Python functions.</li>
<li>Create a property from the compiled functions.</li>
<li>Bind the property to the class.</li>
<li>Create an AST for the <code>__init__</code> method.</li>
<li>Compile the <code>__init__</code> AST to a function.</li>
<li>Bind the <code>__init__</code> function to the class.</li>
</ul>
<p>Each class variable with an annotation is represented by a <code>MacroItem</code>:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MacroItem</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">var_name</span><span>, </span><span style="color:#bf616a;">annotation</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.var = var_name
</span><span>        </span><span style="color:#bf616a;">self</span><span>.annotation = annotation
</span><span>        </span><span style="color:#bf616a;">self</span><span>.lower = </span><span style="color:#d08770;">None
</span><span>        </span><span style="color:#bf616a;">self</span><span>.upper = </span><span style="color:#d08770;">None
</span><span>        </span><span style="color:#bf616a;">self</span><span>.getter = </span><span style="color:#d08770;">None
</span><span>        </span><span style="color:#bf616a;">self</span><span>.setter = </span><span style="color:#d08770;">None
</span><span>        </span><span style="color:#bf616a;">self</span><span>.init_stmt = </span><span style="color:#d08770;">None
</span></code></pre>
<p>These <code>MacroItem</code>s get passed to the functions that extract information from the annotation, generate ASTs, etc. For example, here is the function that generates a getter from a <code>MacroItem</code>:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">getter</span><span>(</span><span style="color:#bf616a;">item</span><span>):
</span><span>    func_name = </span><span style="color:#b48ead;">f</span><span>&quot;{item.var}</span><span style="color:#a3be8c;">_getter</span><span>&quot;
</span><span>    self_arg = </span><span style="color:#bf616a;">arg</span><span>(</span><span style="color:#bf616a;">arg</span><span>=&quot;</span><span style="color:#a3be8c;">self</span><span>&quot;, </span><span style="color:#bf616a;">annotation</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>    func_args = </span><span style="color:#bf616a;">arguments</span><span>(
</span><span>        </span><span style="color:#bf616a;">args</span><span>=[self_arg],
</span><span>        </span><span style="color:#bf616a;">kwonlyargs</span><span>=[],
</span><span>        </span><span style="color:#bf616a;">vararg</span><span>=</span><span style="color:#d08770;">None</span><span>,
</span><span>        </span><span style="color:#bf616a;">kwarg</span><span>=</span><span style="color:#d08770;">None</span><span>,
</span><span>        </span><span style="color:#bf616a;">defaults</span><span>=[],
</span><span>        </span><span style="color:#bf616a;">kw_defaults</span><span>=[],
</span><span>    )
</span><span>    inst_var = </span><span style="color:#bf616a;">Attribute</span><span>(
</span><span>        </span><span style="color:#bf616a;">value</span><span>=</span><span style="color:#bf616a;">Name</span><span>(</span><span style="color:#bf616a;">id</span><span>=&quot;</span><span style="color:#a3be8c;">self</span><span>&quot;, </span><span style="color:#bf616a;">ctx</span><span>=ast.</span><span style="color:#bf616a;">Load</span><span>()), </span><span style="color:#bf616a;">attr</span><span>=</span><span style="color:#b48ead;">f</span><span>&quot;</span><span style="color:#a3be8c;">_</span><span>{item.var}&quot;, </span><span style="color:#bf616a;">ctx</span><span>=ast.</span><span style="color:#bf616a;">Load</span><span>()
</span><span>    )
</span><span>    ret_stmt = </span><span style="color:#bf616a;">Return</span><span>(</span><span style="color:#bf616a;">value</span><span>=inst_var)
</span><span>    func_node = </span><span style="color:#bf616a;">FunctionDef</span><span>(
</span><span>        </span><span style="color:#bf616a;">name</span><span>=func_name,
</span><span>        </span><span style="color:#bf616a;">args</span><span>=func_args,
</span><span>        </span><span style="color:#bf616a;">body</span><span>=[ret_stmt],
</span><span>        </span><span style="color:#bf616a;">decorator_list</span><span>=[],
</span><span>        </span><span style="color:#bf616a;">returns</span><span>=</span><span style="color:#d08770;">None</span><span>,
</span><span>    )
</span><span>    mod_node = </span><span style="color:#bf616a;">Module</span><span>(</span><span style="color:#bf616a;">body</span><span>=[func_node])
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">_ast_to_func</span><span>(mod_node, func_name)
</span></code></pre>
<p>Note that you can't compile a <code>FunctionDef</code> node by itself, you have to wrap it in a <code>Module</code> node first. Here is the magic that compiles an AST into a function.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">ast_to_func</span><span>(</span><span style="color:#bf616a;">node</span><span>, </span><span style="color:#bf616a;">name</span><span>):
</span><span>    ast.</span><span style="color:#bf616a;">fix_missing_locations</span><span>(node)
</span><span>    code = </span><span style="color:#96b5b4;">compile</span><span>(node, __file__, &quot;</span><span style="color:#a3be8c;">exec</span><span>&quot;)
</span><span>    context = {}
</span><span>    </span><span style="color:#96b5b4;">exec</span><span>(code, </span><span style="color:#96b5b4;">globals</span><span>(), context)
</span><span>    </span><span style="color:#b48ead;">return </span><span>context[name]
</span></code></pre>
<p>This definitively shows that you can make Rust-like macros in Python. That's not to say that it's easy or recommended though. Constructing an AST is definitely (the AST for <code>-10</code> is ~4x as many characters as <code>10</code>), so it can be tedious. It was a fun exercise, but I'll show you a better way to make code-generating macros.</p>
<h1 id="example-2-notify">Example 2 - <code>@notify</code></h1>
<p>For my next trick, I've made a decorator <code>@notify</code> that will print a message to the terminal when you try to assign a new value to a class or instance variable marked with a specific annotation.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>@</span><span style="color:#bf616a;">notify
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    var: &quot;</span><span style="color:#a3be8c;">this one</span><span>&quot; = </span><span style="color:#d08770;">5
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">x</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.x = x
</span><span>        </span><span style="color:#bf616a;">self</span><span>.y: &quot;</span><span style="color:#a3be8c;">this one</span><span>&quot; = </span><span style="color:#d08770;">0
</span></code></pre>
<p>If you try typing that into the Python shell, it will crash. If you're working in the shell and you decorate a class with <code>@notify</code> that has an <code>__init__</code> method, it will crash. I have no idea what that's about. If you want to try this in the shell, put the annotation on a class variable. You can put whatever you want into a file though, and it will work just fine. Let's see what happens when you try to assign to a variable you've marked.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">from </span><span>annotation_abuse.notify </span><span style="color:#b48ead;">import </span><span>notify
</span><span>
</span><span>
</span><span>@</span><span style="color:#bf616a;">notify
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MyClass</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">x</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.x = x
</span><span>        </span><span style="color:#bf616a;">self</span><span>.y: &quot;</span><span style="color:#a3be8c;">this one</span><span>&quot; = </span><span style="color:#d08770;">0
</span><span>
</span><span>
</span><span style="color:#b48ead;">if </span><span>__name__ == &quot;</span><span style="color:#a3be8c;">__main__</span><span>&quot;:
</span><span>    foo = </span><span style="color:#bf616a;">MyClass</span><span>()
</span><span>    foo.y = </span><span style="color:#d08770;">1
</span></code></pre>
<p>Run this, and you'll see a familiar face:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>   _________________________________________________
</span><span>  /                                                 \
</span><span>  | It looks like you&#39;re trying to update MyClass.y |
</span><span>  |                 from &quot;0&quot; to &quot;1&quot;.                |
</span><span>  |       Would you like some help with that?       |
</span><span>  \_________________________________________________/
</span><span>
</span><span>    \
</span><span>     \
</span><span>        __
</span><span>       /  \
</span><span>       |  |
</span><span>       @  @
</span><span>       || |/
</span><span>       || ||
</span><span>       |\_/|
</span><span>       \___/
</span><span>
</span><span>Let Clippy update the value? (y/n):
</span></code></pre>
<p>If you say yes:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Let Clippy update the value? (y/n): y
</span><span>   _____________
</span><span>  /             \
</span><span>  | No problem! |
</span><span>  \_____________/
</span><span>
</span><span>    \
</span><span>     \
</span><span>        __
</span><span>       /  \
</span><span>       |  |
</span><span>       @  @
</span><span>       || |/
</span><span>       || ||
</span><span>       |\_/|
</span><span>       \___/
</span></code></pre>
<p>If you say no:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Let Clippy update the value? (y/n): n
</span><span>   ______
</span><span>  /      \
</span><span>  | FINE |
</span><span>  \______/
</span><span>
</span><span>    \
</span><span>     \
</span><span>        __
</span><span>       /  \
</span><span>       \  /
</span><span>       @  @
</span><span>       || |/
</span><span>       || ||
</span><span>       |\_/|
</span><span>       \___/
</span><span>
</span></code></pre>
<p>This example was easier in some ways, but harder in others. I'm not constructing ASTs, so the code is much less verbose. On the other hand, I'm overriding <code>MyClass.__setattr__</code> in order to intercept writes to the marked variables. Boy oh boy was that a can of worms.</p>
<p>Annotations on class variables can be pulled from <code>MyClass.__annotations__</code> (like the previous example), but annotations that appear inside <code>__init__</code> don't show up there. To find those annotations, I parse <code>__init__</code> into an AST (look, I'm sorry, I couldn't help myself), then traverse the tree looking for things that have the annotation <code>&quot;this one&quot;</code>.</p>
<p>Once I've built a list of attributes to watch, I need to intercept writes to those attributes. I knew I could intercept writes to certain attributes by replacing them with properties, but I wondered if there was a different way to do it (just for kicks). I went back to the documentation for the <a href="https://docs.python.org/3/reference/datamodel.html">data model</a> and read up on <code>__setattr__</code>. The <code>__setattr__</code> method gets called when you try to set the value of an attribute, so overriding <code>__setattr__</code> will let me intercept writes to the attributes I care about.</p>
<p>I generate a new <code>__setattr__</code> as a closure, as you can see below:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">make_setattr</span><span>(</span><span style="color:#bf616a;">cls</span><span>, </span><span style="color:#bf616a;">var_names</span><span>):
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">new_setattr</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">attr_name</span><span>, </span><span style="color:#bf616a;">new_value</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span>attr_name not in var_names:
</span><span>            </span><span style="color:#96b5b4;">setattr</span><span>(</span><span style="color:#bf616a;">self</span><span>, attr_name, new_value)
</span><span>            </span><span style="color:#b48ead;">return
</span><span>        </span><span style="color:#65737e;"># The instance variable will be set for the first time during
</span><span>        </span><span style="color:#65737e;"># __init__, but we don&#39;t want to prompt the user on instantiation.
</span><span>        </span><span style="color:#b48ead;">if </span><span>attr_name not in </span><span style="color:#bf616a;">self</span><span>.__dict__.</span><span style="color:#bf616a;">keys</span><span>():
</span><span>            </span><span style="color:#96b5b4;">setattr</span><span>(</span><span style="color:#bf616a;">self</span><span>, attr_name, new_value)
</span><span>            </span><span style="color:#b48ead;">return
</span><span>        current_value = </span><span style="color:#bf616a;">self</span><span>.__dict__[attr_name]
</span><span>        attr = </span><span style="color:#bf616a;">cls</span><span>.__name__ + &quot;</span><span style="color:#a3be8c;">.</span><span>&quot; + attr_name
</span><span>        </span><span style="color:#bf616a;">show_message</span><span>(attr, current_value, new_value)
</span><span>        user_resp = </span><span style="color:#bf616a;">prompt_user</span><span>()
</span><span>        </span><span style="color:#b48ead;">if </span><span>user_resp == Response.</span><span style="color:#bf616a;">YES</span><span>:
</span><span>            </span><span style="color:#bf616a;">no_problem_message</span><span>()
</span><span>            </span><span style="color:#96b5b4;">setattr</span><span>(</span><span style="color:#bf616a;">self</span><span>, attr_name, new_value)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>user_resp == Response.</span><span style="color:#bf616a;">NO</span><span>:
</span><span>            </span><span style="color:#bf616a;">angry_message</span><span>()
</span><span>
</span><span style="color:#b48ead;">return </span><span>new_setattr
</span></code></pre>
<p>I model the user's response with an enum, storing the acceptable responses in the value of each enum variant to make it easier to validate the response. The <code>Response.INVALID</code> case is handled in the <code>prompt_user</code> function. Rust taught me how powerful enums can be, so now I want to use them everywhere!</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Response</span><span style="color:#eff1f5;">(</span><span style="color:#a3be8c;">Enum</span><span style="color:#eff1f5;">):
</span><span>    </span><span style="color:#bf616a;">YES </span><span>= [&quot;</span><span style="color:#a3be8c;">y</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Y</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">yes</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Yes</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">YES</span><span>&quot;]
</span><span>    </span><span style="color:#bf616a;">NO </span><span>= [&quot;</span><span style="color:#a3be8c;">n</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">N</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">no</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">No</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">NO</span><span>&quot;]
</span><span>    </span><span style="color:#bf616a;">INVALID </span><span>= &quot;&quot;
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">interpret_resp</span><span>(</span><span style="color:#bf616a;">text</span><span>):
</span><span>    </span><span style="color:#65737e;">&quot;&quot;&quot;Interpret the user&#39;s response.&quot;&quot;&quot;
</span><span>    resp = text.</span><span style="color:#bf616a;">strip</span><span>()
</span><span>    </span><span style="color:#b48ead;">if </span><span>resp in Response.</span><span style="color:#bf616a;">YES</span><span>.value:
</span><span>        </span><span style="color:#b48ead;">return </span><span>Response.</span><span style="color:#bf616a;">YES
</span><span>    </span><span style="color:#b48ead;">elif </span><span>resp in Response.</span><span style="color:#bf616a;">NO</span><span>.value:
</span><span>        </span><span style="color:#b48ead;">return </span><span>Response.</span><span style="color:#bf616a;">NO
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span>Response.</span><span style="color:#bf616a;">INVALID
</span></code></pre>
<p>One thing I found confusing during this process is that lots of documentation surrounding <code>__setattr__</code> says that you should call the super class's <code>__setattr__</code> when you're overriding <code>__setattr__</code>, and most documentation just cites <code>object.__setattr__(self, name, value)</code>. I found the documentation around this to be sparse, at best, and I only accidentally stumbled onto a solution. Here's what happened.</p>
<p>My working solution uses <code>setattr</code>, so let's replace <code>setattr(self, attr_name, new_value)</code> with <code>object.__setattr__(self, attr_name, new_value)</code>:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>TypeError: can&#39;t apply this __setattr__ to type object
</span></code></pre>
<p>Huh? I searched the internet for what this error message meant, and my understanding is that it's related to setting new attributes on built-in types. So, that tells me that I was accidentally trying to set a new attribute on <code>object</code>. Using <code>super(cls, self).__setattr__</code> gives you the same error.</p>
<p>Let's try <code>super().__setattr__(self, attr_name, new_value)</code> and see if it just sorts itself out:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>RuntimeError: super(): __class__ cell not found
</span></code></pre>
<p>Ok, this one actually makes sense (<a href="https://docs.python.org/3/reference/datamodel.html#creating-the-class-object">see here</a>). In short, I'm calling <code>super()</code> in a function that's not bound to a class when it's defined, so it doesn't know what class it belongs to. I think.</p>
<p>Eventually I just tried <code>setattr</code> and it worked. I was pressed for time preparing this for a lightning talk, so I didn't have time to really dig into the issue. If someone knows what's going on, let me know!</p>
<h1 id="taking-it-to-the-next-level">Taking it to the next level</h1>
<p>I presented the two examples above in a lightning talk at PyOhio 2018. The reception was good, and I ended up talking to Dan Lindeman and Jace Browning in an open space about alternative uses for type annotations. As we were talking, we came to a realization.</p>
<p>Remember earlier when I said that a type annotation can be any valid Python expression? Well, lots of things are valid Python expressions. Say, for instance, a <code>lambda</code>. Take a look:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&gt;&gt;&gt; class MyClass:
</span><span>...     foo: lambda x: 0 &lt; x &lt; 5
</span><span>...
</span><span>
</span><span>&gt;&gt;&gt; MyClass.__annotations__[&quot;foo&quot;](3)
</span><span>True
</span></code></pre>
<p>If you're not amazed that this is possible, check your pulse. This is saying that you can attach entire functions to an attribute, not just a string or a type! It's like every variable carries around a little suitcase that can hold (almost) anything you want!</p>
<p>I think I'm done with this particular project for now, but I'm sure there's all kinds of <s>terrible</s> wonderful things you can do with this. If you have any ideas, I'd love to hear them! The code for all of this can be found on my GitHub at <a href="https://github.com/zmitchell/annotation-abuse">zmitchell/annotation-abuse</a>.</p>

</article>


    
    <footer role="contentinfo">
      <hr />
      <nav class="pagination pagination__onlynext">
        
        
    </nav>
      
      <small>
        
        
      </small>
      
    </footer>
    

  </main>
  
  
</body>

</html>