<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Using Python&#x27;s asyncio with serial devices &middot; Tinkering</title>
  <meta name="description" content="After learning about async&#x2F;await in Python I wondered how I could apply it to software in my lab. Much of that involves talking to equipment via serial ports. Libraries for talking to serial ports exist, but I found the documentation for doing so via async&#x2F;await sparse. Here&#x27;s an example of how to use PySerial asynchronously." />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#aa0000">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://tinkering.xyz/rss.xml">

  <style>
    *,:after,:before{box-sizing:border-box}:root{--color-bg: #f2f2f2;--color-dark: #222222;--color-mid: #ced4da;--color-light: #dee2e6;--color-accent: #089ce7;--text-width: 70ch;--size-base: clamp(1rem, 0.96rem + 0.22vw, 1.125rem);--size-step-0: clamp(0.8125rem, 0.79rem + 0.11vw, 0.875rem);--size-step-1: clamp(1.1875rem, 1.12rem + 0.33vw, 1.375rem);--size-step-2: clamp(1.4375rem, 1.33rem + 0.54vw, 1.75rem);--size-step-3: clamp(1.6875rem, 1.51rem + 0.87vw, 2.1875rem);--size-step-4: clamp(2.0625rem, 1.85rem + 1.09vw, 2.6875rem);--font-face: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
		"Segoe UI Symbol"}body{background:var(--color-bg);color:var(--color-dark);font-size:var(--size-base);font-family:var(--font-face);line-height:1.6;text-rendering:optimizeSpeed}h1{font-size:var(--size-step-3)}h2{font-size:var(--size-step-2)}h3{font-size:var(--size-step-1);line-height:1.2}main{margin:auto;max-width:var(--text-width);padding:0.8rem}@media (max-width: var(--text-width)){.homepage-list a{width:100%}}a{color:currentColor;text-decoration-line:underline;text-decoration-color:var(--color-accent);text-decoration-thickness:0.15em;text-underline-offset:0.15em;text-decoration-skip-ink:none}a:hover{text-decoration-thickness:0.3em;text-underline-offset:0.05em}blockquote{border-left-color:var(--color-accent);border-left-width:0.25em;border-left-style:solid;margin-left:0em;margin-right:0em;padding:0.5em;background-color:var(--color-mid)}td{border:1px solid var(--color-dark);padding:10px}img{margin:auto;height:auto;display:block;max-width:100%}.nav__link{margin-left:0;margin-right:1em}.homepage-list{display:flex;flex-direction:column;list-style:none;padding:0;margin-top:0em}.homepage-list a{text-decoration-thickness:0.05em;-webkit-text-decoration-thickness:0.05em}.pagination{display:flex;justify-content:space-between}.pagination__onlynext{justify-content:flex-end}.post{display:flex;flex-direction:column;justify-content:flex-start;align-items:flex-start;margin-top:0}.post__title{margin:0;line-height:1.2em;justify-content:flex-start}.post__date{display:block;margin-top:0;margin-bottom:0.5em;font-style:italic}.post__description{margin-top:0;margin-bottom:2em}pre{overflow:scroll;padding:1rem}code{font-size:90%}code:not(pre>code){padding:.15em .25em;color:var(--color-dark);background-color:var(--color-light);border-radius:3px}

  </style>

  <meta property="og:site_name" content="Tinkering">
  <meta name="author" content="Zach Mitchell" />
  <meta property="og:title" content="Using Python&#x27;s asyncio with serial devices">
  <meta property="og:description" content="After learning about async&#x2F;await in Python I wondered how I could apply it to software in my lab. Much of that involves talking to equipment via serial ports. Libraries for talking to serial ports exist, but I found the documentation for doing so via async&#x2F;await sparse. Here&#x27;s an example of how to use PySerial asynchronously.">
  <meta property="og:url" content="https://tinkering.xyz/async-serial/">
  <meta property="og:image"
    content="">

  <meta property="og:type" content="article" />
  <meta property="article:published_time" content=" 2018-03-15T00:00:00+00:00" />

  
  
  

</head>


<body>
  <main id="main" role="main">

    
    <header role="banner">
      <h3 style="margin-top:0;">
        <a href="https://tinkering.xyz" title="Home">Tinkering</a>
        <br /><small>Come for the Foo, stay for the Bar</small>
      </h3>
      <nav role="navigation">
        
          <a class="nav__link" href="/">Home</a>
        
          <a class="nav__link" href="https://github.com/zmitchell">GitHub</a>
        
          <a class="nav__link" href="/about/">About</a>
        
      </nav>
    </header>
    <hr />
    

    
<article>
  <h1>Using Python&#x27;s asyncio with serial devices</h1>

  
  <p style="font-size:90%;">Posted on <time datetime=" 2018-03-15T00:00:00+00:00">March 15, 2018</time></p>
  

  
  <div>
    <p>Table of Contents:</p>
    <ul>
      
      <li>
        <a href="https://tinkering.xyz/async-serial/#virtual-serial-ports-with-socat">Virtual serial ports with socat</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/async-serial/#synchronous-serial-communication">Synchronous serial communication</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/async-serial/#the-asynchronous-story">The asynchronous story</a>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/async-serial/#subclassing-asyncio-protocol">Subclassing asyncio.Protocol</a>
        
        <ul>
          
          <li>
            <a href="https://tinkering.xyz/async-serial/#writer">Writer</a>
          </li>
          
          <li>
            <a href="https://tinkering.xyz/async-serial/#reader">Reader</a>
          </li>
          
          <li>
            <a href="https://tinkering.xyz/async-serial/#the-rest">The rest</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/async-serial/#streams">Streams</a>
        
        <ul>
          
          <li>
            <a href="https://tinkering.xyz/async-serial/#streams-and-queues">Streams and Queues</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a href="https://tinkering.xyz/async-serial/#conclusion">Conclusion</a>
        
      </li>
      
    </ul>
  </div>
  

  <p>I'm an experimental physicist, so part of my job entails writing software that orchestrates equipment in my experiment. Most of the code that runs my experiment is written in a proprietary scripting language that I guarantee none of you have ever heard of. The old code is brittle, difficult to debug, and generally makes it too much of a pain to add features unless absolutely necessary. Lately I've been thinking about how I would do a modernized rewrite in Python.
<a name="continue-reading"></a></p>
<p>If you're working in an industrial, IoT, or scientific setting you might find yourself communicating with various devices via serial protocols. In my experience, ASCII-over-serial is the JSON of the scientific world in the sense that just about any piece of equipment you buy will have some sort of ASCII/serial support. For example, every single piece of equipment in my experiment uses ASCII-over-serial.</p>
<p>Lots of serial devices still default to a baud rate (bitrate) of 9600, or ~830us per character (byte). Your processor is running at several GHz. Furthermore, a read operation that times out will block the whole time it's waiting. Have some empathy for the machine. Give it permission to do something interesting when it would otherwise be dying of boredom.</p>
<p>I've written this article because despite <code>asyncio</code> blowing up the Python world, and despite <a href="https://pyserial.readthedocs.io/en/latest/pyserial.html"><code>pyserial</code></a> (the de-facto serial library) providing an <code>asyncio</code>-compatible module, there is basically nothing written about how to actually <em>use</em> these two things together. Let's fix that.</p>
<p>A quick note before I get your hopes up: async serial doesn't yet work on Windows. Furthermore, the async serial functionality is listed as &quot;experimental,&quot; so maybe don't bet your entire business on it.</p>
<p>Alright, enough hedging, let's get down to business.</p>
<h1 id="virtual-serial-ports-with-socat">Virtual serial ports with <code>socat</code></h1>
<p>It would be a real shame if you needed a real serial device to even try this out. Luckily, some smart people made a tool called <a href="http://www.dest-unreach.org/socat/"><code>socat</code></a> which lets you create virtual serial ports. Not only is this great for just tooling around, but it also means that you can test your serial-facing code in a CI environment as opposed to using a hardware loopback adapter or sticking a wire into the TX/RX pins of a serial cable (experimental physicists are half Einstein, half MacGyver).</p>
<p>This is the command I'll use to create a pair of virtual serial ports:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">socat -d -d -v</span><span> pty,rawer,echo=0,link=./reader pty,rawer,echo=0,link=./writer
</span></code></pre>
<ul>
<li><code>-d -d</code> specifies the logging level.</li>
<li><code>-v</code> writes the data sent to each device to the terminal.</li>
<li><code>pty</code> specifies that the device should be a pseudoterminal.</li>
<li><code>rawer</code> is the sound a lion makes.</li>
<li><code>echo</code> specifies whether each port should echo the data sent to it.</li>
<li><code>link</code> is explained below.</li>
</ul>
<p>When you run this command <code>socat</code> creates two virtual serial ports in <code>/dev/</code> that are connected to one another, but it's not guaranteed to connect to those same devices every time. To make this more deterministic you can use the <code>link=&lt;path&gt;</code> option which creates a symlink at <code>&lt;path&gt;</code> to the device in <code>/dev/</code>. I've created two symlinks located at <code>./reader</code> and <code>./writer</code> so that I know exactly which paths to use when connecting to the serial ports in Python. There's a variety of other options that can be specified when using <code>socat</code>, so I encourage you to take a look at the <a href="http://www.dest-unreach.org/socat/doc/socat.html">docs</a> if you're interested in learning more.</p>
<h1 id="synchronous-serial-communication">Synchronous serial communication</h1>
<p>If you're using a serial port right now in Python, you're probably using the <code>pyserial</code> library to do something like this:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">from </span><span>serial </span><span style="color:#b48ead;">import </span><span>Serial
</span><span>
</span><span>ser = </span><span style="color:#bf616a;">Serial</span><span>(&#39;</span><span style="color:#a3be8c;">/dev/ttysomething</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">9600</span><span>, </span><span style="color:#bf616a;">timeout</span><span>=</span><span style="color:#d08770;">0.5</span><span>)
</span><span>ser.</span><span style="color:#bf616a;">write</span><span>(</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">foo</span><span>&#39;)
</span><span>ser.</span><span style="color:#bf616a;">read</span><span>(num_bytes)
</span></code></pre>
<p>You create a <code>Serial</code> object by telling it which device to connect to and how the connection should be configured. Once you have the <code>Serial</code> object you can send or receive bytes from the serial port via the <code>Serial.write</code> and <code>Serial.read</code> methods respectively. To create a class representing some equipment that uses this connection, you can just pass the <code>Serial</code> object into the constructor.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">from </span><span>serial </span><span style="color:#b48ead;">import </span><span>Serial
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">MeasurementDevice</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ser</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.ser = ser
</span><span>        </span><span style="color:#bf616a;">self</span><span>.idn = </span><span style="color:#d08770;">None
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_identifier</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.ser.</span><span style="color:#bf616a;">write</span><span>(</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">?IDN</span><span>&#39;)
</span><span>        response_length = </span><span style="color:#d08770;">10
</span><span>        </span><span style="color:#bf616a;">self</span><span>.idn = </span><span style="color:#bf616a;">self</span><span>.ser.</span><span style="color:#bf616a;">read</span><span>(response_length)
</span><span>
</span><span>foo = </span><span style="color:#bf616a;">Serial</span><span>(&#39;</span><span style="color:#a3be8c;">/dev/ttysomething/</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">9600</span><span>, </span><span style="color:#bf616a;">timeout</span><span>=</span><span style="color:#d08770;">0.5</span><span>)
</span><span>my_device = </span><span style="color:#bf616a;">MeasurementDevice</span><span>(foo)
</span></code></pre>
<p>You could of course just create the connection inside the constructor, but if your class takes the <code>Serial</code> object as an argument you can provide it objects configured in different ways in different situations i.e. configured to connect to <code>/dev/something</code> in production and configured to connect to <code>/foo/bar</code> in tests.</p>
<h1 id="the-asynchronous-story">The asynchronous story</h1>
<p><strong>Aside:</strong> I will not be covering the basics of <code>asyncio</code>, that is beyond the scope of this post.</p>
<p>It would be great if <a href="http://pyserial-asyncio.readthedocs.io/en/latest/index.html"><code>pyserial-asyncio</code></a> provided a magically async version of the <code>Serial</code> class, but that doesn't exist yet. Here is a list of what <code>pyserial-asyncio</code> does provide:</p>
<ul>
<li><code>serial_asyncio.SerialTransport</code></li>
<li><code>serial_asyncio.create_serial_connection</code></li>
<li><code>serial_asyncio.open_serial_connection</code></li>
</ul>
<p>The <code>SerialTransport</code> class is a subclass of <code>asyncio.Transport</code>, and is really what allows all of this async serial stuff to work. Setting that aside, there are two ways to bring async to your serial code:</p>
<ul>
<li>Create a subclass of <code>asyncio.Protocol</code> that uses <code>serial_asyncio.SerialTransport</code> as its transport.</li>
<li>Generate an <code>asyncio.StreamReader</code>/<code>asyncio.StreamWriter</code> pair.</li>
</ul>
<p>I consider subclassing <code>asyncio.Protocol</code> to be the hard way, so we'll look at that first.</p>
<h1 id="subclassing-asyncio-protocol">Subclassing <code>asyncio.Protocol</code></h1>
<p>The <code>asyncio</code> module provides some helpful classes for handling asynchronous communication over a network connection. Two pieces of that puzzle are <code>asyncio.Transport</code> and <code>asyncio.Protocol</code>. A transport represents a type of connection, and handles the buffering and I/O. A protocol, which uses a transport, is generally responsible for telling the transport what to write, and for interpreting the data coming from the transport.</p>
<p>You tell your protocol how to behave by implementing a set of callbacks (see the <a href="https://docs.python.org/3/library/asyncio-protocol.html#protocols">docs</a> for the list of callbacks). These callbacks are called by the transport in response to certain events i.e. when a connection is opened, when data arrives, etc. The default implementations of the callbacks are all empty, so we only need to override the methods that we're actually interested in. The callbacks we'll focus on are <code>connection_made</code>, <code>connection_lost</code>, and <code>data_received</code>.</p>
<p>Let's see an example. Suppose I have a device that produces ASCII messages that are terminated with a newline character, and suppose I want to read and print those messages. I'll make my imaginary device using one protocol subclass (<code>Writer</code>), and I'll read the messages it sends with another protocol subclass (<code>Reader</code>).</p>
<h2 id="writer"><code>Writer</code></h2>
<p>Here is the protocol subclass that will send the messages:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Writer</span><span style="color:#eff1f5;">(</span><span style="color:#a3be8c;">asyncio.Protocol</span><span style="color:#eff1f5;">):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">connection_made</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">transport</span><span>):
</span><span>        </span><span style="color:#65737e;">&quot;&quot;&quot;Store the serial transport and schedule the task to send data.
</span><span style="color:#65737e;">        &quot;&quot;&quot;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.transport = transport
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Writer connection created</span><span>&#39;)
</span><span>        asyncio.</span><span style="color:#bf616a;">ensure_future</span><span>(</span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">send</span><span>())
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Writer.send() scheduled</span><span>&#39;)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">connection_lost</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">exc</span><span>):
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Writer closed</span><span>&#39;)
</span><span>
</span><span>    </span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">send</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#65737e;">&quot;&quot;&quot;Send four newline-terminated messages, one byte at a time.
</span><span style="color:#65737e;">        &quot;&quot;&quot;
</span><span>        message = </span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">foo</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">bar</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">baz</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">qux</span><span style="color:#96b5b4;">\n</span><span>&#39;
</span><span>        </span><span style="color:#b48ead;">for </span><span>b </span><span style="color:#b48ead;">in </span><span>message:
</span><span>            </span><span style="color:#b48ead;">await </span><span>asyncio.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">0.5</span><span>)
</span><span>            </span><span style="color:#bf616a;">self</span><span>.transport.serial.</span><span style="color:#bf616a;">write</span><span>(</span><span style="color:#bf616a;">bytes</span><span>([b]))
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">Writer sent: </span><span>{</span><span style="color:#bf616a;">bytes</span><span>([b])}&#39;)
</span><span>        </span><span style="color:#bf616a;">self</span><span>.transport.</span><span style="color:#bf616a;">close</span><span>()
</span></code></pre>
<p>The <code>connection_made</code> and <code>connection_lost</code> methods will each be called once per connection. If you need to do any setup or teardown, those methods are a good place to do it. The transport passed to <code>connection_made</code> will be a <code>SerialTransport</code>, and it will have a field <code>SerialTransport.serial</code> that is a <code>Serial</code> instance. We'll use this <code>Serial</code> instance to read and write data to the serial port.</p>
<p>I've defined a coroutine function <code>send</code> that is responsible for sending messages a single character at a time with a delay of 0.5 seconds between characters. I've made <code>send</code> a coroutine function rather than a normal function because I want there to be a delay between characters, but calling <code>time.sleep(0.5)</code> would block the whole program, which kind of defeats the purpose when I'm trying to teach you about non-blocking I/O.</p>
<p>When you want to close the connection you call the <code>Transport.close</code> method, which will trigger the <code>Protocol.connection_lost</code> callback. I've sprinkled in some <code>print</code> statements so that if you run this on your own you'll see the flow of execution and things being scheduled on the event loop.</p>
<h2 id="reader"><code>Reader</code></h2>
<p>Here is the protocol subclass that will receive messages:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Reader</span><span style="color:#eff1f5;">(</span><span style="color:#a3be8c;">asyncio.Protocol</span><span style="color:#eff1f5;">):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">connection_made</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">transport</span><span>):
</span><span>        </span><span style="color:#65737e;">&quot;&quot;&quot;Store the serial transport and prepare to receive data.
</span><span style="color:#65737e;">        &quot;&quot;&quot;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.transport = transport
</span><span>        </span><span style="color:#bf616a;">self</span><span>.buf = </span><span style="color:#bf616a;">bytes</span><span>()
</span><span>        </span><span style="color:#bf616a;">self</span><span>.msgs_recvd = </span><span style="color:#d08770;">0
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Reader connection created</span><span>&#39;)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">data_received</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">data</span><span>):
</span><span>        </span><span style="color:#65737e;">&quot;&quot;&quot;Store characters until a newline is received.
</span><span style="color:#65737e;">        &quot;&quot;&quot;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.buf += data
</span><span>        </span><span style="color:#b48ead;">if b</span><span>&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39; in </span><span style="color:#bf616a;">self</span><span>.buf:
</span><span>            lines = </span><span style="color:#bf616a;">self</span><span>.buf.</span><span style="color:#bf616a;">split</span><span>(</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;)
</span><span>            </span><span style="color:#bf616a;">self</span><span>.buf = lines[-</span><span style="color:#d08770;">1</span><span>]  </span><span style="color:#65737e;"># whatever was left over
</span><span>            </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>lines[:-</span><span style="color:#d08770;">1</span><span>]:
</span><span>                </span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">Reader received: </span><span>{line.</span><span style="color:#bf616a;">decode</span><span>()}&#39;)
</span><span>                </span><span style="color:#bf616a;">self</span><span>.msgs_recvd += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span>.msgs_recvd == </span><span style="color:#d08770;">4</span><span>:
</span><span>            </span><span style="color:#bf616a;">self</span><span>.transport.</span><span style="color:#bf616a;">close</span><span>()
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">connection_lost</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">exc</span><span>):
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Reader closed</span><span>&#39;)
</span></code></pre>
<p>This time in <code>connection_made</code> I create an emtpy <code>bytes</code> object that I will use to store the received characters. For the sake of brevity I also store a count of how many complete messages I've received, and I'll use this as my termination condition since I know exactly how many messages that <code>Writer</code> will send (I designed it after all).</p>
<p>The interesting part of <code>Reader</code> is <code>data_received</code>. You aren't guaranteed whether you receive data byte-by-byte or in chunks, so doing the comparison <code>data == b'\n'</code> isn't guaranteed to work. Instead, I just add the new data to the buffer and then check whether there's a newline in there somewhere. If there is, I split the buffer on the newlines and increment the number of messages that have been received. I stop once I've read the number of messages that I know <code>Writer</code> will send.</p>
<h2 id="the-rest">The rest</h2>
<p>I've shown you the interesting bits, so here's the rest of the stuff that you need to run the program (I've put the whole program on GitHub <a href="https://github.com/zmitchell/async-serial/blob/master/async_serial_protocol.py">here</a>):</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">import </span><span>serial_asyncio
</span><span>
</span><span style="color:#65737e;"># Reader, Writer
</span><span>
</span><span>loop = asyncio.</span><span style="color:#bf616a;">get_event_loop</span><span>()
</span><span>reader = serial_asyncio.</span><span style="color:#bf616a;">create_serial_connection</span><span>(loop, Reader, &#39;</span><span style="color:#a3be8c;">reader</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">115200</span><span>)
</span><span>writer = serial_asyncio.</span><span style="color:#bf616a;">create_serial_connection</span><span>(loop, Writer, &#39;</span><span style="color:#a3be8c;">writer</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">115200</span><span>)
</span><span>asyncio.</span><span style="color:#bf616a;">ensure_future</span><span>(reader)
</span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Reader scheduled</span><span>&#39;)
</span><span>asyncio.</span><span style="color:#bf616a;">ensure_future</span><span>(writer)
</span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Writer scheduled</span><span>&#39;)
</span><span>loop.</span><span style="color:#bf616a;">call_later</span><span>(</span><span style="color:#d08770;">10</span><span>, loop.stop)
</span><span>loop.</span><span style="color:#bf616a;">run_forever</span><span>()
</span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Done</span><span>&#39;)
</span></code></pre>
<p>Here I'm importing the requisite modules and setting all of the async stuff into motion. The <code>create_serial_connection</code> function takes a protocol subclass along with any arguments you want to pass to the constructor of <code>Serial</code> i.e. <code>baudrate</code>. The value returned by <code>create_serial_connection</code> is a coroutine object that creates connections to that particular serial port. Finally, I schedule the execution of the <code>reader</code> and <code>writer</code> coroutine objects, and schedule the loop to stop 10 seconds later.</p>
<p>If all goes well, you should see something like this in your terminal:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Reader scheduled
</span><span>Writer scheduled
</span><span>Reader connection created
</span><span>Writer connection created
</span><span>Writer.send() scheduled
</span><span>Writer sent: b&#39;f&#39;
</span><span>Writer sent: b&#39;o&#39;
</span><span>Writer sent: b&#39;o&#39;
</span><span>Writer sent: b&#39;\n&#39;
</span><span>Reader received: foo
</span><span>Writer sent: b&#39;b&#39;
</span><span>Writer sent: b&#39;a&#39;
</span><span>Writer sent: b&#39;r&#39;
</span><span>Writer sent: b&#39;\n&#39;
</span><span>Reader received: bar
</span><span>Writer sent: b&#39;b&#39;
</span><span>Writer sent: b&#39;a&#39;
</span><span>Writer sent: b&#39;z&#39;
</span><span>Writer sent: b&#39;\n&#39;
</span><span>Reader received: baz
</span><span>Writer sent: b&#39;q&#39;
</span><span>Writer sent: b&#39;u&#39;
</span><span>Writer sent: b&#39;x&#39;
</span><span>Writer sent: b&#39;\n&#39;
</span><span>Writer closed
</span><span>Reader received: qux
</span><span>Reader closed
</span><span>Done
</span></code></pre>
<p>This is a pretty trivial example. Neither protocol needs to communicate with the outside world, so they basically just go off and do their own thing. Subclassing <code>Protocol</code> gives you lots of control over the behavior of the connection, but it's not immediately obvious how you get data <em>out</em> of your <code>Protocol</code>.</p>
<p>One method is to override the default constructor as a way of storing some kind of connection to the outside world. In the constructor you'll take an argument that is a resource shared between your protocol subclass and the rest of your code. This resource could be an <code>asyncio.Queue</code>, for instance. Here's how that would look:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">import </span><span>asyncio
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Reader</span><span style="color:#eff1f5;">(</span><span style="color:#a3be8c;">asyncio.Protocol</span><span style="color:#eff1f5;">):
</span><span>    </span><span style="color:#65737e;">&quot;&quot;&quot;Receives newline-terminated messages and places them on a queue.
</span><span style="color:#65737e;">    &quot;&quot;&quot;
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">queue</span><span>):
</span><span>        </span><span style="color:#96b5b4;">super</span><span>().</span><span style="color:#96b5b4;">__init__</span><span>()
</span><span>        </span><span style="color:#bf616a;">self</span><span>.transport = </span><span style="color:#d08770;">None
</span><span>        </span><span style="color:#bf616a;">self</span><span>.queue = queue
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">connection_made</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">transport</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.transport = transport
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">data_received</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">data</span><span>):
</span><span>        </span><span style="color:#65737e;">&quot;&quot;&quot;Store received messages on the queue.
</span><span style="color:#65737e;">        &quot;&quot;&quot;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.buf += data
</span><span>        </span><span style="color:#b48ead;">if b</span><span>&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39; in </span><span style="color:#bf616a;">self</span><span>.buf:
</span><span>            lines = </span><span style="color:#bf616a;">self</span><span>.buf.</span><span style="color:#bf616a;">split</span><span>(</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;)
</span><span>            </span><span style="color:#bf616a;">self</span><span>.buf = lines[-</span><span style="color:#d08770;">1</span><span>]  </span><span style="color:#65737e;"># whatever was left over
</span><span>            </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>lines[:-</span><span style="color:#d08770;">1</span><span>]:
</span><span>                asyncio.</span><span style="color:#bf616a;">ensure_future</span><span>(</span><span style="color:#bf616a;">self</span><span>.queue.</span><span style="color:#bf616a;">put</span><span>(line))
</span></code></pre>
<p>In the constructor I store the queue, and in <code>data_received</code> I place complete messages onto the queue as they arrive. The <code>create_serial_connection</code> function won't pass anything to the constructor of your protocol subclass, so you'll need to somehow store the queue before handing the subclass to <code>create_serial_connection</code>. This is exactly the kind of problem that <code>functools.partial</code> was meant to solve. The <code>partial</code> function lets you specify some of the arguments to a function right now, and get back a function that takes the remaining arguments. In our case we're specifying the arguments to the constructor of <code>Reader</code>, and getting back something that will create <code>Reader</code> instances without needing any arguments.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">import </span><span>serial_asyncio
</span><span style="color:#b48ead;">from </span><span>functools </span><span style="color:#b48ead;">import </span><span>partial
</span><span>
</span><span style="color:#65737e;"># ...
</span><span>
</span><span>my_queue = asyncio.</span><span style="color:#bf616a;">Queue</span><span>()
</span><span>reader_with_queue = </span><span style="color:#bf616a;">partial</span><span>(Reader, my_queue)
</span><span>loop = asyncio.</span><span style="color:#bf616a;">get_event_loop</span><span>()
</span><span>reader = serial_asyncio.</span><span style="color:#bf616a;">create_serial_connection</span><span>(loop, reader_with_queue, &quot;</span><span style="color:#a3be8c;">port_name</span><span>&quot;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">115200</span><span>)
</span><span>
</span><span style="color:#65737e;"># ...
</span></code></pre>
<p>I've modified the <code>Reader</code>/<code>Writer</code> example to use a queue as described above and put it <a href="https://github.com/zmitchell/async-serial/blob/master/async_serial_protocol_queue.py">here</a>. This obviously works, but it feels like a lot of work to do something relatively simple. Isn't there an easier way?</p>
<h1 id="streams">Streams</h1>
<p>I'm glad you asked! As mentioned above, subclassing <code>asyncio.Protocol</code> has its drawbacks. A simpler solution is to use the <code>serial_asyncio.open_serial_connection</code> function (note the difference in names: <code>create_serial_connection</code> vs. <code>open_serial_connection</code>) to generate an <code>asyncio.StreamReader</code>/<code>asyncio.StreamWriter</code> pair.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>reader, writer = </span><span style="color:#b48ead;">await </span><span>serial_asyncio.</span><span style="color:#bf616a;">open_serial_connection</span><span>(</span><span style="color:#bf616a;">url</span><span>=&#39;</span><span style="color:#a3be8c;">&lt;your_device&gt;</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">115200</span><span>)
</span></code></pre>
<p>There's no need to subclass anything, you just call a function. The <code>url='&lt;your_device&gt;'</code> bit is a little odd (what do URLs have to do with anything?)<sup class="footnote-reference"><a href="#1">1</a></sup>, but <code>&lt;your_device&gt;</code> is just the name of the serial device i.e. <code>/dev/ttysomething</code>.</p>
<p>Using these two objects could not be easier. If you want to read from your serial device, you call one of the <code>read</code> coroutine methods on your <code>StreamReader</code> (<code>read</code>, <code>readexactly</code>, <code>readuntil</code>, or <code>readline</code>). If you want to write to your serial device, you call the <code>write</code> method on your <code>StreamWriter</code>. Let's see an example.</p>
<h2 id="streams-and-queues">Streams and Queues</h2>
<p>Let's say that I have two devices, <code>reader</code> and <code>writer</code>, and one of them will send messages to the other. Here's the entire program:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">import </span><span>asyncio
</span><span style="color:#b48ead;">import </span><span>serial_asyncio
</span><span>
</span><span>
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">main</span><span>(</span><span style="color:#bf616a;">loop</span><span>):
</span><span>    reader, </span><span style="color:#bf616a;">_ </span><span>= </span><span style="color:#b48ead;">await </span><span>serial_asyncio.</span><span style="color:#bf616a;">open_serial_connection</span><span>(</span><span style="color:#bf616a;">url</span><span>=&#39;</span><span style="color:#a3be8c;">./reader</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">115200</span><span>)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Reader created</span><span>&#39;)
</span><span>    </span><span style="color:#bf616a;">_</span><span>, writer = </span><span style="color:#b48ead;">await </span><span>serial_asyncio.</span><span style="color:#bf616a;">open_serial_connection</span><span>(</span><span style="color:#bf616a;">url</span><span>=&#39;</span><span style="color:#a3be8c;">./writer</span><span>&#39;, </span><span style="color:#bf616a;">baudrate</span><span>=</span><span style="color:#d08770;">115200</span><span>)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Writer created</span><span>&#39;)
</span><span>    messages = [</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">foo</span><span style="color:#96b5b4;">\n</span><span>&#39;, </span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">bar</span><span style="color:#96b5b4;">\n</span><span>&#39;, </span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">baz</span><span style="color:#96b5b4;">\n</span><span>&#39;, </span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">qux</span><span style="color:#96b5b4;">\n</span><span>&#39;]
</span><span>    sent = </span><span style="color:#bf616a;">send</span><span>(writer, messages)
</span><span>    received = </span><span style="color:#bf616a;">recv</span><span>(reader)
</span><span>    </span><span style="color:#b48ead;">await </span><span>asyncio.</span><span style="color:#bf616a;">wait</span><span>([sent, received])
</span><span>
</span><span>
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">send</span><span>(</span><span style="color:#bf616a;">w</span><span>, </span><span style="color:#bf616a;">msgs</span><span>):
</span><span>    </span><span style="color:#b48ead;">for </span><span>msg </span><span style="color:#b48ead;">in </span><span>msgs:
</span><span>        w.</span><span style="color:#bf616a;">write</span><span>(msg)
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">sent: </span><span>{msg.</span><span style="color:#bf616a;">decode</span><span>().</span><span style="color:#bf616a;">rstrip</span><span>()}&#39;)
</span><span>        </span><span style="color:#b48ead;">await </span><span>asyncio.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">0.5</span><span>)
</span><span>    w.</span><span style="color:#bf616a;">write</span><span>(</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">DONE</span><span style="color:#96b5b4;">\n</span><span>&#39;)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Done sending</span><span>&#39;)
</span><span>
</span><span>
</span><span style="color:#b48ead;">async def </span><span style="color:#8fa1b3;">recv</span><span>(</span><span style="color:#bf616a;">r</span><span>):
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        msg = </span><span style="color:#b48ead;">await </span><span>r.</span><span style="color:#bf616a;">readuntil</span><span>(</span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;)
</span><span>        </span><span style="color:#b48ead;">if </span><span>msg.</span><span style="color:#bf616a;">rstrip</span><span>() == </span><span style="color:#b48ead;">b</span><span>&#39;</span><span style="color:#a3be8c;">DONE</span><span>&#39;:
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Done receiving</span><span>&#39;)
</span><span>            </span><span style="color:#b48ead;">break
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">received: </span><span>{msg.</span><span style="color:#bf616a;">rstrip</span><span>().</span><span style="color:#bf616a;">decode</span><span>()}&#39;)
</span><span>
</span><span>
</span><span>loop = asyncio.</span><span style="color:#bf616a;">get_event_loop</span><span>()
</span><span>loop.</span><span style="color:#bf616a;">run_until_complete</span><span>(</span><span style="color:#bf616a;">main</span><span>(loop))
</span><span>loop.</span><span style="color:#bf616a;">close</span><span>()
</span></code></pre>
<p>In <code>main</code> I create my <code>reader</code> and <code>writer</code> objects, define the messages that will be sent, then create two coroutine objects for actually doing the reading/writing. At the end of <code>main</code> I say to wait for the reading and writing to finish before calling it quits.</p>
<p>I defined two coroutine functions <code>send</code> and <code>recv</code>, and each one does what it says on the tin. The <code>send</code> coroutine function takes a <code>StreamWriter</code> and a list of messages, then sends one message every 0.5 seconds. The <code>recv</code> coroutine function takes a <code>StreamReader</code> and tries to read until a newline character is encountered. If the message is <code>DONE</code>, then we pack up and go home, otherwise we print the message.</p>
<p>This is about as close as it gets to having a magically async-aware <code>Serial</code> class. In fact, if you wanted to make an async-aware <code>Serial</code> class, you could do it just by wrapping the various <code>read</code> and <code>write</code> methods of your stream reader/writer.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Well, that wraps things up. I recommend going the <code>StreamReader</code>/<code>StreamWriter</code> route unless you need fine-grained control over how your connection is handled. Another word of caution: make sure you actually need <code>asyncio</code> before you commit to it. There's a definite learning curve to <code>asyncio</code>, and it adds another layer of complexity. Having said that, go have some fun with <code>asyncio</code> and serial devices!</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><code>open_serial_connection</code> calls <code>create_serial_connection</code>, which calls <code>serial.serial_for_url</code>, which will in most cases just call the <code>Serial</code> constructor with the arguments supplied to <code>serial_for_url</code>. <code>open_serial_connection</code> also requires that you specify all of its arguments as keyword arguments, but most of these arguments just get passed straight to <code>serial_for_url</code>. <code>serial_for_url</code> has a parameter called <code>url</code>, which gets passed to <code>Serial</code> as <code>portname</code> if you haven't specified a URL. So, the <code>portname</code> parameter of the <code>Serial</code> constructor comes from <code>serial_for_url</code>'s <code>url</code> parameter all the way up in <code>open_serial_connection</code>.</p>
</div>

</article>


    
<hr/>
<small>
  <p>P.S. - You can follow me on Mastodon at <a href="https://hachyderm.io/@zmitchell">@zmitchell</a> for Rust, Nix, lukewarm takes, and cat photos.</p>
  <p>P.P.S. - If you notice that something could be more accessible, please reach out and I'll do my best to fix it!</p>
</small>


  </main>
  
  
</body>

</html>