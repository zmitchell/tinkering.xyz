<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tinkering</title>
        <link>https://tinkering.xyz</link>
        <description>Come for the Foo, stay for the Bar</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://tinkering.xyz/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Thu, 06 Jun 2019 11:33:37 -0500</lastBuildDate>
        
            <item>
                <title>Polsim - a case study for small-scale scientific computing in Rust</title>
                <pubDate>Thu, 06 Jun 2019 11:33:37 -0500</pubDate>
                <link>https://tinkering.xyz/polsim/</link>
                <guid>https://tinkering.xyz/polsim/</guid>
                <description>&lt;!-- Math rendering --&gt;
&lt;script src=&#x27;https:&#x2f;&#x2f;cdnjs.cloudflare.com&#x2f;ajax&#x2f;libs&#x2f;mathjax&#x2f;2.7.5&#x2f;latest.js?config=TeX-MML-AM_CHTML&#x27; async&gt;&lt;&#x2f;script&gt;
&lt;script type=&quot;text&#x2f;x-mathjax-config&quot;&gt;
MathJax.Hub.Config({tex2jax: {inlineMath: [[&#x27;$&#x27;,&#x27;$&#x27;], [&#x27;\\(&#x27;,&#x27;\\)&#x27;]]}});
&lt;&#x2f;script&gt;
&lt;p&gt;Let&#x27;s get this out of the way: &lt;code&gt;polsim&lt;&#x2f;code&gt; is a command line utility for doing &lt;strong&gt;pol&lt;&#x2f;strong&gt;arization &lt;strong&gt;sim&lt;&#x2f;strong&gt;ulations. I&#x27;m a physicist by day (shell of a man by night), and I work with lasers on a daily basis. My PhD is based on a measurement technique&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; that&#x27;s polarization-sensitive, so it would be useful to be able to predict or ballpark the polarization of a laser beam without too much trouble. The code can be found on GitHub:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;zmitchell&#x2f;polarization&quot;&gt;&lt;code&gt;polarization&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;: the library that handles the simulations&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;zmitchell&#x2f;polsim&quot;&gt;&lt;code&gt;polsim&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;: the command line utility for using &lt;code&gt;polarization&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The motivation for this post is to recount my experiences developing a scientific tool written in Rust in the context of someone with a scientific background&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;. I&#x27;ll explain why I made certain choices, and I&#x27;ll document the things that I struggled with along the way.&lt;&#x2f;p&gt;
&lt;h1 id=&quot;polarization&quot;&gt;Polarization&lt;&#x2f;h1&gt;
&lt;p&gt;I&#x27;m not here to teach you physics, but a little bit of background is required. I&#x27;ll keep it to a minimum so that I don&#x27;t give you nightmares.&lt;&#x2f;p&gt;
&lt;p&gt;Polarization is loosely defined as how light oscillates as it travels through space. See the image below:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;upload.wikimedia.org&#x2f;wikipedia&#x2f;commons&#x2f;0&#x2f;09&#x2f;Circular.Polarization.Circularly.Polarized.Light_Homogenous_Circular.Polarizer_Left.Handed.svg&quot; alt=&quot;circular and linear polarization&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Technically speaking, polarization is a vector, meaning that it has a size and a direction, which is why the polarization is represented by an arrow in the figure above (the size is the length of the arrow, the direction is the direction the arrow is pointing). The red line is the path traced out by the tip of the polarization vector. For linearly polarized light, the vector just swings back and forth along some line (this is the middle portion of the image). For circularly polarized light, the vector traces out a circle if you look at the beam head-on&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;, or a spiral if you look at the beam traveling through space&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The polarization of a beam changes when it interacts with other objects, for instance, when the beam reflects from a surface or passes through some optical element (e.g. a polarizer). We want to be able to predict what will happen to the polarization of a beam after it interacts with a series of optical elements. Conversely, we could also look at the polarization before and after some optical elements and ask &amp;quot;what could have made my beam look this way&amp;quot;. This kind of modeling is what &lt;code&gt;polsim&lt;&#x2f;code&gt; is for.&lt;&#x2f;p&gt;
&lt;p&gt;Luckily, there are standard techniques for this kind of modeling so I don&#x27;t need reinvent that wheel. The formalism that &lt;code&gt;polsim&lt;&#x2f;code&gt; is based on is called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Jones_calculus&quot;&gt;Jones calculus&lt;&#x2f;a&gt;. Jones calculus is relatively simple but approximates reality well enough for my purposes. There is a more complete formalism called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Mueller_calculus&quot;&gt;Mueller calculus&lt;&#x2f;a&gt; but it&#x27;s more complex and I don&#x27;t need the additional information it provides.&lt;&#x2f;p&gt;
&lt;h1 id=&quot;jones-calculus&quot;&gt;Jones calculus&lt;&#x2f;h1&gt;
&lt;p&gt;Jones calculus informs the structure of &lt;code&gt;polsim&lt;&#x2f;code&gt; so I need to discuss this a little bit. In Jones calculus your polarization is a vector (basically a one-column matrix) of complex numbers&lt;&#x2f;p&gt;
&lt;p&gt;$$
\vec{E} = \begin{bmatrix} A \\ B e^{i\delta} \end{bmatrix} = \begin{bmatrix} \text{complex} \\ \text{complex} \end{bmatrix}
$$&lt;&#x2f;p&gt;
&lt;p&gt;and optical elements, the things that interact with your beam, are 2x2 matrices of complex numbers:&lt;&#x2f;p&gt;
&lt;p&gt;$$
M = \begin{bmatrix}
m_{00} &amp;amp; m_{01} \\ m_{10} &amp;amp; m_{11} \end{bmatrix} = \begin{bmatrix} \text{complex} &amp;amp; \text{complex} \\ \text{complex} &amp;amp; \text{complex} \end{bmatrix}
$$&lt;&#x2f;p&gt;
&lt;p&gt;You obtain the final polarization by multiplying the initial polarization by all the elements that the beam interacts with, like so:&lt;&#x2f;p&gt;
&lt;p&gt;$$
E_{f} = M_{N} \times \ldots \times M_2 \times M_1 \times E_i
$$&lt;&#x2f;p&gt;
&lt;p&gt;So, when you really get down to it, you&#x27;re just multiplying 2x2 matrices together. That fact means that I don&#x27;t need a ton of computational horsepower, freeing me up to make decisions based on preference rather than necessity. I&#x27;ll discuss this further when it comes to which linear algebra crate I chose.&lt;&#x2f;p&gt;
&lt;p&gt;In principle you could do all of this multiplication by hand. In fact, if you&#x27;re trying to see how one particular parameter of an optical element influences the final result, it&#x27;s often a good idea to do this multiplication by hand to get an analytical solution. However, these matrices can get ugly and doing the arithmetic by hand is tedious:&lt;&#x2f;p&gt;
&lt;p&gt;$$
\begin{bmatrix} \cos^{2}\left(\theta\right) + e^{i\varphi} \sin^{2}\left(\theta\right) &amp;amp; \sin\left(\theta\right)\cos\left(\theta\right) - e^{i\varphi} \sin\left(\theta\right)\cos\left(\theta\right) \\ \sin\left(\theta\right)\cos\left(\theta\right) - e^{i\varphi} \sin\left(\theta\right)\cos\left(\theta\right) &amp;amp; \sin^{2}\left(\theta\right) + e^{i\varphi} \cos^{2}\left(\theta\right) \\ \end{bmatrix}
$$&lt;&#x2f;p&gt;
&lt;p&gt;No one has ever used this matrix without looking it up.&lt;&#x2f;p&gt;
&lt;h1 id=&quot;crate-choices&quot;&gt;Crate choices&lt;&#x2f;h1&gt;
&lt;p&gt;Now that I have the background out of the way, I can walk through some of the necessary building blocks:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;complex numbers&lt;&#x2f;li&gt;
&lt;li&gt;vectors (essentially a 1-column matrix)&lt;&#x2f;li&gt;
&lt;li&gt;matrices&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;There&#x27;s no complex number support in the Rust standard library, so I had to look elsewhere. The most mature and feature-complete solution is the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-num&#x2f;num&quot;&gt;&lt;code&gt;num&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate and its &lt;code&gt;num::complex::Complex&lt;&#x2f;code&gt; type. The type &lt;code&gt;Complex&amp;lt;T&amp;gt;&lt;&#x2f;code&gt; is parameterized by some numerical type &lt;code&gt;T&lt;&#x2f;code&gt; e.g. &lt;code&gt;f32&lt;&#x2f;code&gt; or &lt;code&gt;f64&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;My choice in the linear algebra space was made more difficult by the wealth of linear algebra crates that are available. A &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;search?q=linear+algebra&quot;&gt;quick search on crates.io&lt;&#x2f;a&gt; for the query &amp;quot;linear algebra&amp;quot; returns 95 results. There are really two options that stand out: &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-ndarray&#x2f;ndarray&quot;&gt;&lt;code&gt;ndarray&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rustsim&#x2f;nalgebra&quot;&gt;&lt;code&gt;nalgebra&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. The &lt;code&gt;ndarray&lt;&#x2f;code&gt; crate seems to be a generic multi-dimensional array, similar to what NumPy provides in the Python world, whereas &lt;code&gt;nalgebra&lt;&#x2f;code&gt; seems to be more focused on square matrices and vectors for computer graphics. I only need square (2x2) matrices, so I went with &lt;code&gt;nalgebra&lt;&#x2f;code&gt;, though I&#x27;m sure I would have been able to achieve the same results with &lt;code&gt;ndarray&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;I use the &lt;code&gt;nalgebra::Vector2&amp;lt;T&amp;gt;&lt;&#x2f;code&gt; and &lt;code&gt;nalgebra::Matrix2&amp;lt;T&amp;gt;&lt;&#x2f;code&gt; types to represent beams and optical elements respectively, where &lt;code&gt;T&lt;&#x2f;code&gt; is &lt;code&gt;num::complex::Complex&amp;lt;f64&amp;gt;&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h1 id=&quot;the-polarization-crate&quot;&gt;The polarization crate&lt;&#x2f;h1&gt;
&lt;p&gt;Getting back to the code, I needed to translate the physics of the problem into Rust. To do this I made a crate called &lt;code&gt;polarization&lt;&#x2f;code&gt; which does the actual simulation work. &lt;code&gt;polsim&lt;&#x2f;code&gt; allows users to define simulations in a declarative fashion, does validation on those simulation definitions, then hands things off to &lt;code&gt;polarization&lt;&#x2f;code&gt; to do the simulation. &lt;&#x2f;p&gt;
&lt;p&gt;There were two distinct &amp;quot;entities&amp;quot; that I wanted to model, beams and optical elements, so I described each one with its own trait. In Jones calculus the polarization of a beam is represented by a two-element vector. We refer to this type of vector as a &amp;quot;Jones vector&amp;quot;. Some examples of things I expect to be able to do with a beam are get its intensity (brightness), pull out the x&#x2f;y-component, get the underlying vector so I can multiply it with a matrix, and a variety of other things. I came to the following (truncated) definition:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;pub trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;JonesVector {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Intensity of the beam
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;intensity&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; Result&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Returns the x-component of the beam
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Returns the y-component of the beam
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;y&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Returns the vector representation of the beam
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;vector&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; Vector2&amp;lt;Complex&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt;;

    ...
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I implement this trait for a type called &lt;code&gt;Beam&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Basically a container for the Vector2&amp;lt;T&amp;gt;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Beam {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;vec&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Vector2&amp;lt;Complex&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The crate isn&#x27;t actually generic over the &lt;code&gt;JonesVector&lt;&#x2f;code&gt; trait (you&#x27;ll see functions take and return &lt;code&gt;Beam&lt;&#x2f;code&gt; explicitly), but the plan is to rectify that at some point.&lt;&#x2f;p&gt;
&lt;p&gt;For optical elements I again define a trait to encode the behavior that all optical elements should have. This trait is smaller because most of the behavior will be element-specific.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;pub trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;JonesMatrix {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Rotate the element by the given angle
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rotated&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Angle) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Return the matrix representation of the element
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;matrix&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; Matrix2&amp;lt;Complex&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt;;

    ...

}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; An ideal linear polarizer
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Polarizer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mat&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Matrix2&amp;lt;Complex&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;&amp;gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;JonesMatrix &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Polarizer {
    ...
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;In order to perform this simulation you need exactly one beam and at least one element for the beam to propagate through. You can represent a vacuum (which won&#x27;t change the polarization of the beam) with an identity matrix, so you really have no excuse for doing a simulation without at least one optical element. Another point to consider is that the order in which the beam encounters the optical elements determines the order in which the matrices should be multiplied together&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#6&quot;&gt;5&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;. I&#x27;m not just going to let you multiply matrices together willy-nilly, sorry. &lt;&#x2f;p&gt;
&lt;p&gt;I define a type called &lt;code&gt;OpticalSystem&lt;&#x2f;code&gt; so that there is an adult in the room. You add a beam and some elements to the system, call &lt;code&gt;OpticalSystem::propagate()&lt;&#x2f;code&gt;, and the system will return a &lt;code&gt;Result&amp;lt;Beam, JonesError&amp;gt;&lt;&#x2f;code&gt;. When you put it all together, a very simple simulation looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; initial_beam = Beam::linear(Angle::Degrees(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pol = Polarizer::new(Angle::Degrees(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;45.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; qwp = QuarterWavePlate::new(Angle::Degrees(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; system = OpticalSystem::new()
    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_beam&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(initial_beam)
    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_element&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(pol)
    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add_element&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(qwp);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; final_beam = system.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;propagate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h1 id=&quot;debugging&quot;&gt;Debugging&lt;&#x2f;h1&gt;
&lt;p&gt;The first thing I struggled with was using a debugger. This was my first time using a debugger, so I was already in uncharted territory. At the time I was working on this I was using neovim and a terminal as my &amp;quot;IDE&amp;quot;, but since then I&#x27;ve moved to CLion and I can say that its debugger is relatively pleasant to use.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s start with some minor things, like how values are printed in the debugger. I&#x27;ll first set a breakpoint inside of a closure:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(lldb) br set -f system.rs -l 348
Breakpoint 1: where = polarization-b20b1f754e235950`polarization
::jones::system::OpticalSystem::composed_elements
::_$u7b$$u7b$closure$u7d$$u7d$
::h19d2e65336af7615 + 577 at system.rs:348:30, address = 0x00000001001e8c11
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Most of this looks fine except for the &lt;code&gt;_$u7b$$u7b$closure$u7d$$u7d$&lt;&#x2f;code&gt; piece. I think this is supposed to read &lt;code&gt;{{closure}}&lt;&#x2f;code&gt;, but this isn&#x27;t a big deal because you can still basically read what it says. Now let&#x27;s let the program run until we hit that breakpoint.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(lldb) r
...
Process 33329 stopped
* thread #2, name = &amp;#39;jones::system::test::test_beam_passes_through&amp;#39;, stop reason = breakpoint 1.1
    frame #0: 0x00000001001e8c11 polarization-b20b1f754e235950`polarization::jones::system::OpticalSystem
    ::composed_elements::_$u7b$$u7b$closure$u7d$$u7d$::h19d2e65336af7615((null)=0x000070000ef72f98,
    acc=Matrix&amp;lt;num_complex::Complex&amp;lt;f64&amp;gt;, nalgebra::base::dimension::U2, nalgebra::base::dimension::U2,
    nalgebra::base::matrix_array::MatrixArray&amp;lt;num_complex::Complex&amp;lt;f64&amp;gt;, nalgebra::base::dimension::U2,
    nalgebra::base::dimension::U2&amp;gt;&amp;gt; @ 0x000070000ef73030, elem=0x0000000100c16aa0) at system.rs:348:30
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;There&#x27;s quite a bit more output now. If you wade through the sea of colons&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#5&quot;&gt;6&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;, you can see the the entire second half of this output is just defining the type of a matrix named &lt;code&gt;acc&lt;&#x2f;code&gt; (this is inside of a &lt;code&gt;fold&lt;&#x2f;code&gt;, and &lt;code&gt;acc&lt;&#x2f;code&gt; is the accumulator). The point here is that the actual types of matrices in &lt;code&gt;nalgebra&lt;&#x2f;code&gt; can be very verbose. There is a language feature on the horizon called const-generics that should eventually alleviate some of the pain here.&lt;&#x2f;p&gt;
&lt;p&gt;Getting back to debugging, lets try to find the values inside this matrix &lt;code&gt;acc&lt;&#x2f;code&gt;. You can list the variables in this stack frame with the command &lt;code&gt;fr v&lt;&#x2f;code&gt;. There are three variables in this stack frame, but I&#x27;ll only show one because there&#x27;s a lot to wade through.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(nalgebra::base::matrix::Matrix&amp;lt;num_complex::Complex&amp;lt;double&amp;gt;, nalgebra::base::dimension::U2,
nalgebra::base::dimension::U2, nalgebra::base::matrix_array::MatrixArray&amp;lt;num_complex::Complex&amp;lt;double&amp;gt;,
nalgebra::base::dimension::U2, nalgebra::base::dimension::U2&amp;gt; &amp;gt;) acc = {
  data = {
    data = {
      data = {
        parent1 = {
          parent1 = {
            parent1 = &amp;lt;Unable to determine byte size.&amp;gt;

            parent2 = &amp;lt;Unable to determine byte size.&amp;gt;

            data = (re = 1, im = 0)
          }
          parent2 = {
            parent1 = &amp;lt;Unable to determine byte size.&amp;gt;

            parent2 = &amp;lt;Unable to determine byte size.&amp;gt;

            data = (re = 0, im = 0)
          }
          _marker = {}
        }
        parent2 = {
          parent1 = {
            parent1 = &amp;lt;Unable to determine byte size.&amp;gt;

            parent2 = &amp;lt;Unable to determine byte size.&amp;gt;

            data = (re = 0, im = 0)
          }
          parent2 = {
            parent1 = &amp;lt;Unable to determine byte size.&amp;gt;

            parent2 = &amp;lt;Unable to determine byte size.&amp;gt;

            data = (re = 1, im = 0)
          }
          _marker = {}
        }
        _marker = {}
      }
    }
  }
  _phantoms = {}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Again, you can see that there&#x27;s quite a lot of information here, but there&#x27;s really only four relevant lines:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;...
data = (re = 1, im = 0)
...
data = (re = 0, im = 0)
...
data = (re = 0, im = 0)
...
data = (re = 1, im = 0)
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I know from experience which element of the matrix (row&#x2f;column) each of these values is supposed to appear in, but there&#x27;s no other indicator which &lt;code&gt;data&lt;&#x2f;code&gt; belongs to which row&#x2f;column. I know I&#x27;m really harping on this debugging thing, but debugging is a crucial part of the developer experience. That&#x27;s not to say that effort hasn&#x27;t been put towards this, just that there&#x27;s still plenty of work to be done.&lt;&#x2f;p&gt;
&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;&#x2f;h1&gt;
&lt;p&gt;This is science, so you should be able to rely on the correctness of the results. It&#x27;s generally a good practice to test your code, but that goes doubly so for a scientific tool. In order to really cover my bases I&#x27;m using property based testing (PBT).&lt;&#x2f;p&gt;
&lt;p&gt;For those of you not familiar with PBT here&#x27;s a quick introduction. A unit test for a function that does addition might check a statement like &amp;quot;the sum of 2 and 3 is 5&amp;quot;. In this type of test you know (and supply) the exact input and verify that it produces some known exact output. This test is simple to write and simple to come up with, but doesn&#x27;t provide much confidence that the addition function would work for other inputs.&lt;&#x2f;p&gt;
&lt;p&gt;In PBT you make more general statements about your program and verify them several times with a sequence of randomly generated inputs. This type of test might check a statement like &amp;quot;the sum of two positive integers &lt;strong&gt;x&lt;&#x2f;strong&gt; and &lt;strong&gt;y&lt;&#x2f;strong&gt; is also positive&amp;quot;. The test would randomly generate several positive integers and make sure their sum is greater than zero, giving you the confidence that your addition function works for a wide range of inputs.&lt;&#x2f;p&gt;
&lt;p&gt;There&#x27;s always a tradeoff, however. Your test suite will generally take longer to run since you&#x27;re running each test several times. You will also spend some amount of time debugging broken tests when you discover  edge cases &lt;strong&gt;in your tests&lt;&#x2f;strong&gt; due to the randomly generated inputs.&lt;&#x2f;p&gt;
&lt;p&gt;I think PBT and science should be best friends, and here&#x27;s why: science provides you a wealth of properties to test. Different scientific fields may have more or less difficulty identifying properties that map well to software tests, but for a &amp;quot;hard&amp;quot;, quantitative field like experimental physics, there&#x27;s more properties to test than I care to implement.&lt;&#x2f;p&gt;
&lt;p&gt;For example, here is a very short list of properties I test just in &lt;code&gt;polarization&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The intensity of a beam that&#x27;s passed through two crossed polarizers should be zero.&lt;&#x2f;li&gt;
&lt;li&gt;The intensity of a beam shouldn&#x27;t change if it&#x27;s rotated by an arbitrary angle.&lt;&#x2f;li&gt;
&lt;li&gt;A beam that&#x27;s rotated 360 degrees should look exactly the same as the original beam.&lt;&#x2f;li&gt;
&lt;li&gt;An optical element that&#x27;s rotated 360 should look exactly the same as the original element.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;My PBT crate of choice is &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;AltSysrq&#x2f;proptest&quot;&gt;&lt;code&gt;proptest&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. If you&#x27;ve ever used &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;HypothesisWorks&#x2f;hypothesis&quot;&gt;&lt;code&gt;hypothesis&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; in the Python world, &lt;code&gt;proptest&lt;&#x2f;code&gt; is similar in spirit. The central idea is that there are &amp;quot;strategies&amp;quot; that produce instances of a given type, and your test specifies that its inputs should come from some strategies.&lt;&#x2f;p&gt;
&lt;p&gt;There are strategies for many primitive and built-in types like &lt;code&gt;f64&lt;&#x2f;code&gt;, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2f;code&gt;, etc. You can also create your own strategies or compose strategies together. Those two features allow you to generate instances of complicated types such as &lt;code&gt;OpticalSystem&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;You tell &lt;code&gt;proptest&lt;&#x2f;code&gt; how to randomly generate an instance of your type by implementing the &lt;code&gt;Arbitrary&lt;&#x2f;code&gt; trait. Here&#x27;s what that looks like for my &lt;code&gt;Angle&lt;&#x2f;code&gt; type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Angle {
    Degrees(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;),
    Radians(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;),
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Arbitrary &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Angle {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Parameters = ();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Strategy = BoxedStrategy&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;arbitrary_with&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(_: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Parameters) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Strategy {
        prop_oneof![
            (any::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;()).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;prop_map&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| Angle::Degrees(x)),
            (any::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;()).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;prop_map&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| Angle::Radians(x)),
        ]
        .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;boxed&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Most of this is boilerplate so here&#x27;s the important bit:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;prop_oneof![
    (any::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;()).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;prop_map&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| Angle::Degrees(x)),
    (any::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;()).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;prop_map&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| Angle::Radians(x)),
]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;prop_oneof!&lt;&#x2f;code&gt; macro instructs &lt;code&gt;proptest&lt;&#x2f;code&gt; to randomly select one strategy from a list of strategies, and is useful for generating the different variants of an enum. The &lt;code&gt;any::&amp;lt;T&amp;gt;()&lt;&#x2f;code&gt; function produces a strategy that generates instances of the type &lt;code&gt;T&lt;&#x2f;code&gt;. Both lines in the macro are generating &lt;code&gt;f64&lt;&#x2f;code&gt;s and mapping them into the variants of the &lt;code&gt;Angle&lt;&#x2f;code&gt; enum. So, if I were to call &lt;code&gt;any::&amp;lt;Angle&amp;gt;()&lt;&#x2f;code&gt; I would get a strategy that produces a random stream of &lt;code&gt;Angle::Degrees(some f64)&lt;&#x2f;code&gt; and &lt;code&gt;Angle::Radians(some f64)&lt;&#x2f;code&gt;. In fact, I do exactly that to generate &lt;code&gt;Beam&lt;&#x2f;code&gt;s:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Arbitrary &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Beam {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Parameters = PolarizationKind;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Strategy = BoxedStrategy&amp;lt;Beam&amp;gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;arbitrary_with&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;args&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Parameters) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Strategy {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; args {
            PolarizationKind::Linear =&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;any_linear_beam&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;boxed&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; ... omitted
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;any_linear_beam&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() -&amp;gt; impl Strategy&amp;lt;Value = Beam&amp;gt; {
    any::&amp;lt;Angle&amp;gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;prop_map&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| Beam::linear(angle))
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h1 id=&quot;polsim&quot;&gt;polsim&lt;&#x2f;h1&gt;
&lt;p&gt;With all of that out of the way, we can finally talk about &lt;code&gt;polsim&lt;&#x2f;code&gt; itself. Simulations are defined in a TOML file using a syntax I&#x27;ve laid out in the documentation. Here&#x27;s what it looks like:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;[beam]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;polarization &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;linear&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;90
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle_units &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;degrees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;

[[elements]]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;element_type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;polarizer&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;45
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle_units &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;degrees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;

[[elements]]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;element_type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;qwp&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle_units &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;degrees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It might look odd to have to define the angle units everywhere, but that&#x27;s done on purpose. It can be more convenient to use degrees in one place or radians in another, and I&#x27;m planning on incorporating other angles types in the future (wavelengths and fractions of &lt;code&gt;pi&lt;&#x2f;code&gt;). On top of that, you definitely don&#x27;t want your simulation results to be wrong because you meant radians where &lt;code&gt;polsim&lt;&#x2f;code&gt; thought you meant degrees.&lt;&#x2f;p&gt;
&lt;p&gt;I use &lt;code&gt;serde&lt;&#x2f;code&gt; to deserialize this TOML file into a struct so that I can do some validation. The structs that this gets deserialized into are a bit ugly because I have to account for all possible beam and element definitions. For example, the &lt;code&gt;polarization&lt;&#x2f;code&gt; field in the beam definition determines which other fields are required in the beam definition. Here&#x27;s the struct that a beam gets deserialized into:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(Debug, Deserialize, Serialize)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;BeamDef {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;polarization&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: PolType,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;angle_units&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;AngleType&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x_mag&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x_phase&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y_mag&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y_phase&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;phase_units&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;AngleType&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;handedness&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;HandednessType&amp;gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The next step is to validate the beam definition:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;validate_element&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elem&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;ElemDef) -&amp;gt; Result&amp;lt;OpticalElement&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; elem.element_type {
        ElemType::Polarizer =&amp;gt; {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;validate_polarizer&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(elem).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_err&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|| &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;invalid polarizer definition&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
        }
        ElemType::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;HWP &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;validate_hwp&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(elem).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_err&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|| &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;invalid half-wave plate definition&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;),
        ElemType::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;QWP &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;validate_qwp&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(elem).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_err&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|| &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;invalid quarter-wave plate definition&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;),
        ElemType::Retarder =&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;validate_retarder&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(elem).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_err&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|| &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;invalid retarder definition&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;),
        ElemType::Rotator =&amp;gt; {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;validate_rotator&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(elem).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;chain_err&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|| &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;invalid polarization rotator definition&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You&#x27;ll note that I&#x27;m using &lt;code&gt;error-chain&lt;&#x2f;code&gt; here for my error handling. I&#x27;ve never been very clear on what the in-vogue method of error handling is in the Rust ecosystem, but &lt;code&gt;error-chain&lt;&#x2f;code&gt; makes it very easy to spell out exactly where a user went wrong in their simulation definition:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;$ polsim has_error.toml
error: invalid system definition
caused by: invalid element definition
caused by: invalid polarizer definition
caused by: invalid angle definition
caused by: missing parameter in definition: &amp;#39;angle_units&amp;#39;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If a user defines a simulation with more than one instance of a given optical element, &lt;code&gt;polsim&lt;&#x2f;code&gt; won&#x27;t point out which one has the error, so there&#x27;s some work to do there.&lt;&#x2f;p&gt;
&lt;p&gt;Another area that needs work is the output because it&#x27;s currently very basic:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;$ polsim examples&#x2f;circular_polarizer.toml
intensity: 5.00000e-1
x_mag: 5.00000e-1
x_phase: 0.00000e0
y_mag: 5.00000e-1
y_phase: 1.57080e0
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;or&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;$ polsim --table examples&#x2f;circular_polarizer.toml
+------------+------------+-----------+------------+-----------+
| intensity  | x_mag      | x_phase   | y_mag      | y_phase   |
+------------+------------+-----------+------------+-----------+
| 5.00000e-1 | 5.00000e-1 | 0.00000e0 | 5.00000e-1 | 1.57080e0 |
+------------+------------+-----------+------------+-----------+
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The goal is to have the initial and final polarization plotted with &lt;code&gt;gnuplot&lt;&#x2f;code&gt;, and some preliminary work on that front suggests that it shouldn&#x27;t be very difficult.&lt;&#x2f;p&gt;
&lt;h1 id=&quot;future-work&quot;&gt;Future work&lt;&#x2f;h1&gt;
&lt;p&gt;There&#x27;s a wealth of improvements that could be made to this project, so I&#x27;ll just drop a list of them right here.&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Migrate to the Rust 2018 edition.&lt;&#x2f;li&gt;
&lt;li&gt;Add &lt;code&gt;wavelength&lt;&#x2f;code&gt; and &lt;code&gt;pi&lt;&#x2f;code&gt; angle units.&lt;&#x2f;li&gt;
&lt;li&gt;Plot the initial and final polarization ellipses using &lt;code&gt;gnuplot&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;Add a way to sweep a parameter to see how the result changes as the input changes.&lt;&#x2f;li&gt;
&lt;li&gt;Improve support for custom optical element types.&lt;&#x2f;li&gt;
&lt;li&gt;Add support for reflections from metals&#x2f;dielectrics (blocked by a bug).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2f;h1&gt;
&lt;p&gt;This was a fun project to work on because it gave me an excuse to bring Rust into my day job, but I&#x27;m ready to focus my efforts on other projects for now. I would be more than happy to mentor anyone that wants to contribute, and I&#x27;ve put a good deal of effort into making sure that the documentation is thorough and easy to read.&lt;&#x2f;p&gt;
&lt;p&gt;As for the state of the Rust ecosystem, I still don&#x27;t think it&#x27;s quite there yet for the average scientist. I felt pretty comfortable with Rust because I&#x27;m a programming nerd, but I still see Python as the tool of choice for most physicists. Here&#x27;s an illustrative example: find a modified Bessel function of the second kind of order 0. In Python (even if you don&#x27;t know what I just asked) your first step is to search the SciPy documentation (the function is called &lt;code&gt;k0&lt;&#x2f;code&gt; there). In Rust, without looking I&#x27;m not confident that function exists yet. In the Python world you know that &lt;code&gt;X&lt;&#x2f;code&gt; exists somewhere, you just need to find it, but that certainty that &lt;code&gt;X&lt;&#x2f;code&gt; exists isn&#x27;t there yet for Rust. Give it time and I think Rust will start to show up in some surprising places.&lt;&#x2f;p&gt;
&lt;p&gt;I don&#x27;t want this to come off as too negative towards Rust, I love it and wish more scientific software was written in it. When it comes to handling communication between equipment or data collection, I see Rust being a superpower due to its speed, safety, and ease of use. I&#x27;ve been toying with the idea of reimplementing the program that controls&#x2f;coordinates the equipment in my experiment because I inherited the spaghettiest of spaghetti code, but at the same time I&#x27;d like to graduate at some point.&lt;&#x2f;p&gt;
&lt;p&gt;Like I mentioned at the beginning, this was just meant to document my experience, but hopefully you at least learned a little bit about polarization. Feel free to open an issue on either of the &lt;code&gt;polsim&lt;&#x2f;code&gt; or &lt;code&gt;polarization&lt;&#x2f;code&gt; repositories if you have any questions!&lt;&#x2f;p&gt;
&lt;h1 id=&quot;footnotes&quot;&gt;Footnotes&lt;&#x2f;h1&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;It&#x27;s an ultrafast circular-dichroism spectrometer, if you must know.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;At this point I&#x27;ve been programming for about half as long as I&#x27;ve been doing science, so I&#x27;m not a complete n00b. That last statement is probably inviting the wrath of The Internet. YOLO&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2f;sup&gt;
&lt;p&gt;APPLY DIRECTLY TO THE FOREHEAD&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2f;sup&gt;
&lt;p&gt;How is it possible for the polarization to spiral? I&#x27;m glad you asked! You can always break down the polarization into two separate pieces that oscillate perpendiular to one another e.g. x- and y-components. If the two components oscillate in lock-step with each other i.e. in phase with each other, you get linear polarization. If one of the components lags behind the other one by a fixed amount, you get elliptical polarization. Circular polarization is a special case of elliptical polarization for which the two components have the same size and one component lags by a quarter of a cycle (a phase of &lt;code&gt;pi&#x2f;2&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;5&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;6&lt;&#x2f;sup&gt;
&lt;p&gt;Admit it, you thought I was going to make a joke about colons here. You know what they say happens when you assume.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;6&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2f;sup&gt;
&lt;p&gt;For you math-inclined folks, these matrices don&#x27;t commute.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>Introduction to Procedural Macros in Rust</title>
                <pubDate>Sat, 03 Feb 2018 19:36:37 -0500</pubDate>
                <link>https://tinkering.xyz/introduction-to-proc-macros/</link>
                <guid>https://tinkering.xyz/introduction-to-proc-macros/</guid>
                <description>&lt;p&gt;As a newcomer to Rust, I heard the phrase &amp;quot;procedural macro&amp;quot; thrown around a lot without really understanding what it meant. I figured that I would learn about them if I ever needed them. Well, I&#x27;m working on the guts of &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;antoyo&#x2f;relm&quot;&gt;&lt;code&gt;relm&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, and a large chunk of it is procedural macros. I&#x27;ve learned enough about procedural macros to be dangerous, so I thought I would pass on some knowledge.&lt;&#x2f;p&gt;
&lt;p&gt;The purpose of this post is to give you an overview of the ins and outs of procedural macros so that you feel confident enough to incorporate them into your own Rust arsenal. I&#x27;ll start off by discussing what makes a declarative macro (&lt;code&gt;macro_rules!&lt;&#x2f;code&gt;) different from a procedural macro, then I&#x27;ll discuss the different types of procedural macros, how to define them, where to define them, and the basics of packaging them. At the end I&#x27;ll walk you through making your very first procedural macro. Here&#x27;s a taste of where we&#x27;re going to end up:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2f;images&#x2f;not-the-bees-editor.jpg&quot; alt=&quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;I&#x27;ve included below a list of other resources you might find helpful. Sometimes you need to hear the same information explained multiple ways before it really sinks in.&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;first-edition&#x2f;macros.html&quot;&gt;Macros - The Rust Programming Language - First Edition&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;first-edition&#x2f;procedural-macros.html&quot;&gt;Procedural Macros (and custom derive) - The Rust Programming Language - First Edition&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;unstable-book&#x2f;language-features&#x2f;proc-macro.html&quot;&gt;proc_macro - The Unstable Book&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;macros-by-example.html&quot;&gt;Macros By Example - The Rust Reference&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;rustbyexample.com&#x2f;macros.html&quot;&gt;Macros - Rust By Example&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;rreverser.com&#x2f;writing-complex-macros-in-rust&#x2f;&quot;&gt;Writing complex macros in Rust&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;Macros in Rust &lt;a href=&quot;https:&#x2f;&#x2f;www.ncameron.org&#x2f;blog&#x2f;macros-in-rust-pt1&#x2f;&quot;&gt;part 1&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;www.ncameron.org&#x2f;blog&#x2f;macros-in-rust-pt2&#x2f;&quot;&gt;part 2&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;www.ncameron.org&#x2f;blog&#x2f;macros-in-rust-pt3&#x2f;&quot;&gt;part 3&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;www.ncameron.org&#x2f;blog&#x2f;macros-in-rust-pt4&#x2f;&quot;&gt;part 4&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;http:&#x2f;&#x2f;words.steveklabnik.com&#x2f;an-overview-of-macros-in-rust&quot;&gt;An Overview of Macros in Rust - Steve Klabnik&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;declarative-macros&quot;&gt;Declarative Macros&lt;&#x2f;h2&gt;
&lt;p&gt;Your first contact with macros is probably &lt;code&gt;macro_rules!&lt;&#x2f;code&gt;. The &lt;code&gt;macro_rules!&lt;&#x2f;code&gt; macro defines a declarative macro. These are great when you want to define a shorthand for something tedious or verbose. For example, I&#x27;m working on a revamped parser for the &lt;code&gt;view!&lt;&#x2f;code&gt; macro in &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;antoyo&#x2f;relm&quot;&gt;&lt;code&gt;relm&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, and I want to be able to test that it can parse several different examples, so I wrote a macro to make my tests much more concise.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#96b5b4;&quot;&gt;macro_rules! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;failed {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ident&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) =&amp;gt; (format!(&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;failed to parse `&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;`&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;macro_rules! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;check_example {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ident&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$y&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;path&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) =&amp;gt; ({
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; _parse_result: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$y &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= syn::parse_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expect&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(failed!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
    })
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;macro_rules! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;check_examples {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ident&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$y&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;path&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) =&amp;gt; ({
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ex in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
            check_example!(ex, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$y&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        }
    })
}

#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;test&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse_message&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; examples = vec![
        &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Message&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Message(x)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Message(x, y, z)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
    ];
    check_examples!(examples, Message);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This post isn&#x27;t about declarative macros, so I&#x27;ll keep this explanation brief. The &lt;code&gt;failed!&lt;&#x2f;code&gt; macro just generates a formatted string saying &lt;code&gt;failed to parse &amp;lt;whatever the example was&amp;gt;&lt;&#x2f;code&gt;. The &lt;code&gt;check_example!&lt;&#x2f;code&gt; macro lets me test that a given example can be parsed into the given type (&lt;code&gt;Message&lt;&#x2f;code&gt; in this case). The &lt;code&gt;check_examples!&lt;&#x2f;code&gt; macro lets me test several examples at once. I&#x27;m not doing anything crazy here, and I&#x27;m not doing anything that couldn&#x27;t be done by hand. I&#x27;m just lazy, and I&#x27;d like my tests to be short and to the point.&lt;&#x2f;p&gt;
&lt;p&gt;It&#x27;s entirely possible to write complex, intricate, incredibly useful declarative macros using this syntax, but (to me, at least) these macro definitions become nearly illegible as they get larger. Procedural macros, in my opinoin, are much better suited to writing something non-trivial.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;procedural-macros-introduction&quot;&gt;Procedural Macros - Introduction&lt;&#x2f;h2&gt;
&lt;p&gt;When you define a macro with &lt;code&gt;macro_rules!&lt;&#x2f;code&gt;, you are writing pattern matching expressions to define what your input should look like, and what output to generate using those matched patterns. When you write a procedural macro, you are handed a fully &lt;s&gt;armed and operational battle station&lt;&#x2f;s&gt; parsed syntax tree, at which point the compiler says &amp;quot;go nuts, just give me back another syntax tree when you&#x27;re done.&amp;quot;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;syntax-trees&quot;&gt;Syntax Trees&lt;&#x2f;h3&gt;
&lt;p&gt;Before we get too deep into procedural macros, you&#x27;ll want to have at least a vague understanding of what a syntax tree is. If you&#x27;re someone like me that doesn&#x27;t come from a computer science background, maybe you don&#x27;t have any idea what a syntax tree is. Well, buckle up, you&#x27;re going to need to get pretty cozy with this concept.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s say we want to parse the definition of a function. How would we represent the pieces of a function definition as a Rust struct? Well, there&#x27;s obviously the characters &lt;code&gt;fn&lt;&#x2f;code&gt; somewhere, so we&#x27;ll store that in our struct. There might also be a &lt;code&gt;pub&lt;&#x2f;code&gt; at the front of the definition, so we&#x27;ll store that as an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;&#x2f;code&gt; of some kind. Then there are parentheses, so we&#x27;ll store those too. What about the contents of the parentheses (the arguments)? There might be nothing there, and there might be a bunch of stuff there. The arguments have names, types, and potentially trait or lifetime bounds, so we&#x27;ll store that as well. This goes on and on until you&#x27;ve built a collection of structs and enums that represent the various bits and pieces of Rust code. This is what the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;syn&#x2f;0.12.12&#x2f;syn&#x2f;&quot;&gt;&lt;code&gt;syn&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate does for you. We&#x27;ll come back to &lt;code&gt;syn&lt;&#x2f;code&gt; in a minute.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;types-of-procedural-macros&quot;&gt;Types of Procedural Macros&lt;&#x2f;h3&gt;
&lt;p&gt;There are three basic kinds of procedural macros: function-like, attribute-like, and custom derive. The procedural macros page in the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;unstable-book&#x2f;language-features&#x2f;proc-macro.html&quot;&gt;Unstable Book&lt;&#x2f;a&gt; contains really useful information about how these are different from one another, and how to define them.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;attribute-like&quot;&gt;Attribute-like&lt;&#x2f;h4&gt;
&lt;p&gt;An attribute-like procedural macro can be used to create a custom attribute like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;my_custom_attribute&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(arg1, arg2)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Foo {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; struct fields
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The definition of an attribute-like procedural macro looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro_attribute&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my_custom_attribute&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; do something
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The first argument is the metadata contained in the attribute i.e. the arguments or values. There are a few different ways to use a custom attribute, so refer back to the Unstable Book for more details. The second argument is the syntax tree of the item that the attribute was applied to (the struct &lt;code&gt;Foo&lt;&#x2f;code&gt; in the example above).&lt;&#x2f;p&gt;
&lt;p&gt;A great example for how to use a custom attribute can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;serde.rs&#x2f;attributes.html&quot;&gt;&lt;code&gt;serde&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate, where they&#x27;re used to customize how a struct&#x2f;enum will be (de)serialized.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;custom-derive&quot;&gt;Custom Derive&lt;&#x2f;h4&gt;
&lt;p&gt;A custom derive is great when you want to make life easier for a consumer of your library. The way a custom derive works is very similar to how a custom attribute works, with some restrictions. A procedural macro for a custom derive only takes one &lt;code&gt;TokenStream&lt;&#x2f;code&gt; as an argument, and can only be applied where the &lt;code&gt;derive&lt;&#x2f;code&gt; attribute is valid i.e. on structs and enums. Here&#x27;s how it looks:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; in the library consumer&amp;#39;s code
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(Foo)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Bar(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; in your proc-macro crate
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro_derive&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(Foo)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;derive_foo&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; do something
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that the name of the function doesn&#x27;t have to be &lt;code&gt;derive_&amp;lt;trait name&amp;gt;&lt;&#x2f;code&gt;, that&#x27;s just what I called it.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;function-like&quot;&gt;Function-Like&lt;&#x2f;h4&gt;
&lt;p&gt;A function-like procedural macro is the Wild West of procedural macros. These are valid anywhere as long as their output is valid at the location the macro is invoked. The definition of a function-like macro only takes one &lt;code&gt;TokenStream&lt;&#x2f;code&gt; as input. Here is what one looks like:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; in the library user&amp;#39;s code
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;my_macro!(all kinds of stuff)

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; in your proc-macro crate
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my_macro&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; do something
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that in the case of a function-like macro, the macro has the same name as the function you apply the &lt;code&gt;#[proc_macro]&lt;&#x2f;code&gt; attribute to.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;summary&quot;&gt;Summary&lt;&#x2f;h4&gt;
&lt;p&gt;Here are the basics all in one place. Take note of the different attributes applied to each function, and the number of arguments that each function takes.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; custom attribute
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro_attribute&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my_attribute&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; do something
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; custom derive
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro_derive&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(TraitName)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my_custom_derive&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; do something
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; function-like macro
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my_macro&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; do something
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;defining-and-packaging-procedural-macros&quot;&gt;Defining and Packaging Procedural Macros&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s talk about how and where you define procedural macros.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;packaging&quot;&gt;Packaging&lt;&#x2f;h3&gt;
&lt;p&gt;Procedural macros must be defined in their own crates. It&#x27;s customary to name a crate containing a custom derive macro with the &lt;code&gt;&amp;lt;crate&amp;gt;-derive&lt;&#x2f;code&gt; pattern, where &lt;code&gt;&amp;lt;crate&amp;gt;&lt;&#x2f;code&gt; is the name of the main crate i.e. &lt;code&gt;serde&lt;&#x2f;code&gt; and &lt;code&gt;serde-derive&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; of your procedural macro crate must be defined as a crate of type &lt;code&gt;proc-macro&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;# in Cargo.toml
[lib]
proc-macro = true
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Procedural macros are still an unstable feature, so you must also put the following line at the root of your procedural macro crate and the crate using the procedural macro:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#![feature(proc_macro)]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;dependencies&quot;&gt;Dependencies&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;proc_macro&#x2f;index.html&quot;&gt;&lt;code&gt;proc-macro&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate is part of the standard library, but you&#x27;ll need a few other crates to make your macros.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; proc_macro;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; syn;
#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;macro_use&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; quote;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We&#x27;ll go through these one by one.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;proc-macro&quot;&gt;&lt;code&gt;proc-macro&lt;&#x2f;code&gt;&lt;&#x2f;h4&gt;
&lt;p&gt;This crate defines the &lt;code&gt;TokenStream&lt;&#x2f;code&gt; type. There&#x27;s not much else to see here as the &lt;code&gt;proc_macro&lt;&#x2f;code&gt; crate is intentionally barebones.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;syn&quot;&gt;&lt;code&gt;syn&lt;&#x2f;code&gt;&lt;&#x2f;h4&gt;
&lt;p&gt;When you&#x27;re writing your procedural macro you&#x27;re going to have about 40 tabs open that start with &lt;code&gt;syn::&lt;&#x2f;code&gt; because this crate defines all of the syntax items that your code will get parsed into. For example, &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;syn&#x2f;0.12.12&#x2f;syn&#x2f;enum.Expr.html&quot;&gt;this&lt;&#x2f;a&gt; is the page for &lt;code&gt;syn::Expr&lt;&#x2f;code&gt;, which is the enum describing all the various types of expressions. Take a look, I&#x27;ll wait. Yeah, there&#x27;s a lot going on there. You&#x27;ll just have to keep the documentation open while you work. That&#x27;s not a bad thing though, because there&#x27;s all kinds of useful stuff in there.&lt;&#x2f;p&gt;
&lt;p&gt;The most recent versions of &lt;code&gt;syn&lt;&#x2f;code&gt; (&lt;code&gt;0.12.x&lt;&#x2f;code&gt;) provide you some really nice tools for creating error messages. Let&#x27;s say your macro allows the user to write code in a custom syntax. The compiler doesn&#x27;t know your custom syntax (you can actually make custom parsers with &lt;code&gt;syn&lt;&#x2f;code&gt;, but that&#x27;s another topic), so you&#x27;re responsible for parsing your custom syntax and generating valid Rust code from it. If you determine that the user has made a syntax error, you can generate a compiler error pointing to the exact location of the error. I&#x27;ll show you how to do this in a minute.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;quote&quot;&gt;&lt;code&gt;quote&lt;&#x2f;code&gt;&lt;&#x2f;h4&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;quote&#x2f;0.4.2&#x2f;quote&#x2f;&quot;&gt;&lt;code&gt;quote&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate is basically the opposite of &lt;code&gt;syn&lt;&#x2f;code&gt; in that it generates tokens rather than parsing them. The basic idea is that you use &lt;code&gt;syn&lt;&#x2f;code&gt; to parse strings or tokens into syntax trees, then use &lt;code&gt;quote&lt;&#x2f;code&gt; to turn syntax trees back into tokens or strings.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;let-s-write-a-the-wicker-man-macro&quot;&gt;Let&#x27;s Write a &amp;quot;The Wicker Man&amp;quot; Macro&lt;&#x2f;h2&gt;
&lt;p&gt;First, some context:&lt;&#x2f;p&gt;
&lt;div &gt;
    &lt;iframe src=&quot;https:&#x2f;&#x2f;www.youtube.com&#x2f;embed&#x2f;EVCrmXW6-Pk&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;
    &lt;&#x2f;iframe&gt;
&lt;&#x2f;div&gt;
&lt;p&gt;Let&#x27;s lay out the requirements for our macro. We want to create a custom attribute that a user can only apply to a struct definition. If the user applies the attribute to an enum, function, etc, we should generate a compiler error. If the struct has a field named &amp;quot;bees,&amp;quot; we want the compiler to lose its mind.&lt;&#x2f;p&gt;
&lt;p&gt;I&#x27;ve posted the code for this macro on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;zmitchell&#x2f;wickerman&quot;&gt;GitHub&lt;&#x2f;a&gt; so you can do all kinds of crazy things with it. If you&#x27;re reading this post to learn procedural macros for the first time, take a look at the commit history of the repo to see how I put the macro together piece by piece. I&#x27;ve largely followed the same process in the sections that follow.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;&#x2f;h3&gt;
&lt;p&gt;Here&#x27;s the most barebones version of our macro crate:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#![&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;feature&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(proc_macro)]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; syn;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; proc_macro;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;proc_macro::TokenStream;

#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;proc_macro_attribute&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;not_the_bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_metadata&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: TokenStream) -&amp;gt; TokenStream {
    input
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This obviously doesn&#x27;t do any of the devious things that we want, but it does compile. That&#x27;s a start.&lt;&#x2f;p&gt;
&lt;p&gt;Next we try to parse the input into a &lt;code&gt;syn::Item&lt;&#x2f;code&gt; using the &lt;code&gt;syn::parse&lt;&#x2f;code&gt; function. In &lt;code&gt;syn&lt;&#x2f;code&gt; parlance, an &lt;code&gt;Item&lt;&#x2f;code&gt; is a syntax tree that can appear at the module level, which includes things like function, struct, and enum definitions. If parsing fails (maybe we&#x27;re trying to parse something that isn&#x27;t an &lt;code&gt;Item&lt;&#x2f;code&gt;), we&#x27;ll panic with the given error message.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Parse the `TokenStream` into a syntax tree, specifically an `Item`. An `Item` is a
&#x2f;&#x2f; syntax item that can appear at the module level i.e. a function definition, a struct
&#x2f;&#x2f; or enum definition, etc.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; item: syn::Item = syn::parse(input).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expect&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;failed to parse input&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Use `quote` to convert the syntax tree back into tokens so we can return them. Note
&#x2f;&#x2f; that the tokens we&amp;#39;re returning at this point are still just the input, we&amp;#39;ve simply
&#x2f;&#x2f; converted it between a few different forms.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; output = quote!{ #item };
output.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Parsing moves the syntax tree, so we can&#x27;t get away with just converting &lt;code&gt;input&lt;&#x2f;code&gt; back into &lt;code&gt;proc_macro::TokenStream&lt;&#x2f;code&gt;. We could just clone &lt;code&gt;input&lt;&#x2f;code&gt; to return a copy of it, but instead we&#x27;ll introduce the &lt;code&gt;quote!&lt;&#x2f;code&gt; macro. The &lt;code&gt;quote!&lt;&#x2f;code&gt; macro lets you write normal Rust code, insert syntax trees into it, and get tokens back. In this case I&#x27;m just turning the parsed &lt;code&gt;Item&lt;&#x2f;code&gt; back into tokens. This is the extent to which we&#x27;ll be using &lt;code&gt;quote&lt;&#x2f;code&gt; in this post, but you can see how to generate more complicated code in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;dtolnay&#x2f;syn&#x2f;tree&#x2f;master&#x2f;examples&#x2f;lazy-static&quot;&gt;&lt;code&gt;lazy_static!&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; example from &lt;code&gt;syn&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;examining-the-syntax-tree&quot;&gt;Examining the Syntax Tree&lt;&#x2f;h3&gt;
&lt;p&gt;A quick perusal of the docs for &lt;code&gt;syn::Item&lt;&#x2f;code&gt; reveals that there are quite a few things that could be considered items. We&#x27;re only looking for &lt;code&gt;syn::Item::Struct&lt;&#x2f;code&gt;, so we&#x27;ll use a &lt;code&gt;match&lt;&#x2f;code&gt; statement:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Match on the parsed item and respond accordingly.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; item {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; If the attribute was applied to a struct, we&amp;#39;re going to do
    &#x2f;&#x2f; some more work to figure out if there&amp;#39;s a field named &amp;quot;bees&amp;quot;.
    &#x2f;&#x2f; It&amp;#39;s important to take a reference to `struct_item`, otherwise
    &#x2f;&#x2f; you partially move `item`.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Item::Struct(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; struct_item) =&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;has_bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(struct_item) {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;light_it_up&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(struct_item);
        }
    },

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; If the attribute was applied to any other kind of item, we want
    &#x2f;&#x2f; to generate a compiler error.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;_ =&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; This is how you generate a compiler error. You can also
        &#x2f;&#x2f; generate a &amp;quot;note,&amp;quot; or a &amp;quot;warning.&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        item.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;span&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unstable&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
            .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;error&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;This is not a struct&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
            .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;emit&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    },
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; Determine if the struct has a field named &amp;quot;bees&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;has_bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;struct_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;syn::ItemStruct) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
    unimplemented!()
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; Generate fun compiler errors
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;light_it_up&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;struct_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;syn::ItemStruct) {
    unimplemented!()
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I like to keep things nice and tidy, so I&#x27;ve introduced two new functions, &lt;code&gt;has_bees&lt;&#x2f;code&gt; and &lt;code&gt;light_it_up&lt;&#x2f;code&gt;, to move some of the code out of the match statement. Notice that each function takes a reference to a &lt;code&gt;syn::ItemStruct&lt;&#x2f;code&gt;, and that I&#x27;m passing &lt;code&gt;struct_item&lt;&#x2f;code&gt; rather than &lt;code&gt;&amp;amp;struct_item&lt;&#x2f;code&gt; to each function. I just want to look at the contents, not take them, so I destructure with &lt;code&gt;ref&lt;&#x2f;code&gt; here.&lt;&#x2f;p&gt;
&lt;p&gt;The other thing to take not of is how I generate the compiler error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;item.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;span&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unstable&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;error&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;This is not a struct&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;emit&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The trait &lt;code&gt;syn::spanned::Spanned&lt;&#x2f;code&gt; allows you to retrieve the span of any syntax tree defined by &lt;code&gt;syn&lt;&#x2f;code&gt;, so you&#x27;ll want to bring that into scope. Why is the &lt;code&gt;unstable()&lt;&#x2f;code&gt; there? I have no idea, but you need it. Rather than &lt;code&gt;error&lt;&#x2f;code&gt; you could also use &lt;code&gt;warning&lt;&#x2f;code&gt;, &lt;code&gt;note&lt;&#x2f;code&gt;, or &lt;code&gt;help&lt;&#x2f;code&gt;. See &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;proc_macro&#x2f;struct.Span.html&quot;&gt;this page&lt;&#x2f;a&gt; for details.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;finding-a-named-field&quot;&gt;Finding a named field&lt;&#x2f;h4&gt;
&lt;p&gt;Let&#x27;s dig into the &lt;code&gt;has_bees&lt;&#x2f;code&gt; function. We want &lt;code&gt;has_bees&lt;&#x2f;code&gt; to examine the syntax tree and return &lt;code&gt;true&lt;&#x2f;code&gt; or &lt;code&gt;false&lt;&#x2f;code&gt; depending on whether there is a field in the struct named &amp;quot;bees.&amp;quot; To do that we&#x27;re going to need to dig into the definition of &lt;code&gt;syn::ItemStruct&lt;&#x2f;code&gt;. I&#x27;ll just show you what this looks like.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; from the `syn` docs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ItemStruct {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;attrs&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Vec&amp;lt;Attribute&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;vis&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Visibility,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;struct_token&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Struct,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ident&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Ident,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;generics&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Generics,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fields&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Fields,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;semi_token&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;Semi&amp;gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Fields {
    Named(FieldsNamed),
    Unnamed(FieldsUnnamed),
    Unit,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;FieldsNamed {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brace_token&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Brace,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;named&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Punctuated&amp;lt;Field, Comma&amp;gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Field {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;attrs&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Vec&amp;lt;Attribute&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;vis&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Visibility,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ident&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;Ident&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;colon_token&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Option&amp;lt;Colon&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ty&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Type,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Yikes, that&#x27;s quite the rabbit hole. Unfortunately, this is the price you pay for all of the goodies that &lt;code&gt;syn&lt;&#x2f;code&gt; gives you for free. Alright, here&#x27;s what we&#x27;re going to do:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;match on &lt;code&gt;fields&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;destructure the &lt;code&gt;Named&lt;&#x2f;code&gt; variant to bind its contents to a variable&lt;&#x2f;li&gt;
&lt;li&gt;use the iterator methods provided by &lt;code&gt;Punctuated&lt;&#x2f;code&gt; to iterate over the fields&lt;&#x2f;li&gt;
&lt;li&gt;compare the &lt;code&gt;ident&lt;&#x2f;code&gt; (name) of each field with &amp;quot;bees&amp;quot;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; Determine if the struct has a field named &amp;quot;bees&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;has_bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;struct_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;syn::ItemStruct) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; struct_.fields {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; A field can only be named &amp;quot;bees&amp;quot; if it has a name, so we&amp;#39;ll
        &#x2f;&#x2f; match those fields and ignore the rest.
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Fields::Named(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; fields) =&amp;gt; {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Unwrap the field names because we know these are named fields.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;            fields.named.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;any&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;field&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| field.ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() == &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
        }
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Ignore unit structs or anonymous fields.
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;_ =&amp;gt; {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;},
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that I&#x27;m able to directly compare the &lt;code&gt;ident&lt;&#x2f;code&gt; with a value of type &lt;code&gt;&amp;amp;str&lt;&#x2f;code&gt; even though &lt;code&gt;ident&lt;&#x2f;code&gt; is of type &lt;code&gt;syn::Ident&lt;&#x2f;code&gt;. This is because &lt;code&gt;Ident&lt;&#x2f;code&gt; implements &lt;code&gt;PartialEq&amp;lt;T: AsRef&amp;lt;str&amp;gt;&amp;gt;&lt;&#x2f;code&gt;, or, in other words, &lt;code&gt;Ident&lt;&#x2f;code&gt; can be compared with types that can be converted to &lt;code&gt;&amp;amp;str&lt;&#x2f;code&gt;. Nice! Although you don&#x27;t need to explicity convert the &lt;code&gt;Ident&lt;&#x2f;code&gt; to a &lt;code&gt;&amp;amp;str&lt;&#x2f;code&gt; or &lt;code&gt;String&lt;&#x2f;code&gt; for the sake of comparison (remember, the &lt;code&gt;PartialEq&lt;&#x2f;code&gt; implementation does it for you), you can still get the textual representation of &lt;code&gt;ident&lt;&#x2f;code&gt; using its &lt;code&gt;as_ref&lt;&#x2f;code&gt; or &lt;code&gt;to_string&lt;&#x2f;code&gt; methods.&lt;&#x2f;p&gt;
&lt;p&gt;Another thing to point out is that I&#x27;m unwrapping &lt;code&gt;ident&lt;&#x2f;code&gt;, which is of type &lt;code&gt;Option&amp;lt;Ident&amp;gt;&lt;&#x2f;code&gt;. This seems odd at first glance. We know that the fields are named because they come from the &lt;code&gt;Fields::Named&lt;&#x2f;code&gt; variant, but the type of each field is &lt;code&gt;Option&amp;lt;Ident&amp;gt;&lt;&#x2f;code&gt;, which suggests that there is some uncertainty as to whether the field actually has a name. According to David Tolnay, one of the authors of &lt;code&gt;syn&lt;&#x2f;code&gt;, this is a trade off. On one hand, it would make more sense to use just &lt;code&gt;Ident&lt;&#x2f;code&gt; in this situation, rather than &lt;code&gt;Option&amp;lt;Ident&amp;gt;&lt;&#x2f;code&gt;. On the other hand, using &lt;code&gt;Option&amp;lt;Ident&amp;gt;&lt;&#x2f;code&gt; for the type of &lt;code&gt;Field.ident&lt;&#x2f;code&gt; allows you to treat named and unnamed fields mostly the same, which makes sense from an API and maintenance point of view. Interesting!&lt;&#x2f;p&gt;
&lt;h4 id=&quot;generating-the-compiler-errors&quot;&gt;Generating the compiler errors&lt;&#x2f;h4&gt;
&lt;p&gt;Now that we&#x27;ve seen how to locate the fields of a struct and generate a compiler error, let&#x27;s go ahead and do this in our &lt;code&gt;light_it_up&lt;&#x2f;code&gt; function (it will look very similar to &lt;code&gt;has_bees&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; Generate fun compiler errors
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;light_it_up&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;struct_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;syn::ItemStruct) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Fields::Named(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; fields) = struct_.fields {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Piece together our exquisite error message.
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; bees = &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;🐝 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;repeat&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;17&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; msg = &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;🐝   not the bees!!! NOT THE BEEEEEES!!! 🐝&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; The `join` method places the provided string between the joined items,
        &#x2f;&#x2f; so putting empty strings at the beginning and end will put extra
        &#x2f;&#x2f; newline characters at the beginning and end of the error message.
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; bees_msg = [&amp;quot;&amp;quot;, bees.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(), msg, bees.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(), &amp;quot;&amp;quot;].&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;join&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Find the field named &amp;quot;bees&amp;quot;.
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; field in &amp;amp;fields.named {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ident = field.ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ident == &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Deliver the error message.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;span&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unstable&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
                    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;error&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(bees_msg.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
                    .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;emit&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
            }
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we&#x27;ll make a simple example to show that it works:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#![&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;feature&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(proc_macro)]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; wickerman;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;wickerman::wickerman;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; This one shouldn&amp;#39;t raise any errors because it doesn&amp;#39;t have a field
&#x2f;&#x2f;&#x2f; named &amp;quot;bees&amp;quot;, or any named fields at all for that matter.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wickerman&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Foo(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; This is where the action will happen.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wickerman&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Bar {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;baz&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: String,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f;&#x2f; This is only here so that the crate will run as a binary crate
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    println!(&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Hello, world!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;*crosses fingers*&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2f;images&#x2f;not-the-bees-editor.jpg&quot; alt=&quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;BINGO! At 1:30am this was basically the funniest thing I had ever seen. I laughed myself to sleep.&lt;&#x2f;p&gt;
&lt;p&gt;Now, there is some weirdness involved. At first the errors only showed up when I tried to build the example in my terminal. I&#x27;m guessing I had to build both the &lt;code&gt;wickerman&lt;&#x2f;code&gt; crate and the example before the error messages would show up in my editor (Sublime Text). I would also like to point out that things may look different in your editor or your terminal because Unicode Is Hard (TM). I know that the error message doesn&#x27;t look like this (different spacing) in either iTerm2 or the built in terminal on macOS, and each terminal renders it differently. I think the issue lies in the width of the bee emoji. I&#x27;m not all that concerned about it.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;blowing-up-the-editor&quot;&gt;Blowing up the editor&lt;&#x2f;h4&gt;
&lt;p&gt;We&#x27;re generating an error message for the field named &amp;quot;bees,&amp;quot; but I said I wanted the compiler to lose its mind. So, here&#x27;s what I want to do: if I find the &amp;quot;bees&amp;quot; field, I&#x27;ll show the bees error message, but for every other field and its type I&#x27;ll show a random error message inspired by The Wicker Man. First, some inspiration (WARNING: GRATUITOUS AMOUNTS OF 240p):&lt;&#x2f;p&gt;
&lt;div &gt;
    &lt;iframe src=&quot;https:&#x2f;&#x2f;www.youtube.com&#x2f;embed&#x2f;Qjme5hh&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;
    &lt;&#x2f;iframe&gt;
&lt;&#x2f;div&gt;
&lt;p&gt;Now let&#x27;s get to work. The first order of business is creating a function to return a random error message. Here&#x27;s the outline:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;random_error_message&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) -&amp;gt; String {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Create the error messages...

    &#x2f;&#x2f; Store the error messages in an array so one can be chosen at random. We use an array
    &#x2f;&#x2f; rather than a `Vec&amp;lt;String&amp;gt;` because we know exactly how many error messages we have,
    &#x2f;&#x2f; and we know the number will never change.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; messages = [
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; List the error messages here.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Use the `rand` crate to choose a random message to return. Note that `choose` returns
    &#x2f;&#x2f; `Option&amp;lt;&amp;amp;T&amp;gt;`, which will only be `None` if `messages` is empty, so it&amp;#39;s safe to unwrap
    &#x2f;&#x2f; here. Unwrapping gives us `&amp;amp;String`, so we call `to_owned` to return `String`.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;rand::thread_rng().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;choose&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;messages).&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_owned&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The next step is to apply the error messages to the other syntax items. I&#x27;ll do this by adding an &lt;code&gt;else&lt;&#x2f;code&gt; branch to the &lt;code&gt;if ident.as_ref() = &amp;quot;bees&amp;quot;&lt;&#x2f;code&gt; conditional statement in &lt;code&gt;light_it_up&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() == &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; You&amp;#39;ve already seen this part.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;} &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Here&amp;#39;s where the new stuff will go.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First I&#x27;ll attach an error message to the identifier (the name of the field), and then I&#x27;ll attach an error message to the type of the field.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() == &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; You&amp;#39;ve already seen this part.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;} &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Show a random error message referencing the name of the field.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;span&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unstable&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;error&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;random_error_message&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()))
        .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;emit&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Show a random error message referencing the type of the field.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    field.ty.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;span&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unstable&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;error&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;random_error_message&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&amp;quot;))
        .&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;emit&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Alright, all the pieces are in place! Let&#x27;s see what it looks like!&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2f;images&#x2f;insanity.jpg&quot; alt=&quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;BEAUTIFUL! I&#x27;m pretty happy with how this looks. To satisfy the purists, I added some feature flags to the &lt;code&gt;wickerman&lt;&#x2f;code&gt; crate. The default feature is &lt;code&gt;just-the-bees-please&lt;&#x2f;code&gt;, which will only show the &amp;quot;not the bees!&amp;quot; message. The other feature is &lt;code&gt;go-nuts&lt;&#x2f;code&gt;, which will show the randomly selected error messages on the other fields and types. I did this using the &lt;code&gt;cfg!&lt;&#x2f;code&gt; macro:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ident.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;as_ref&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() == &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bees&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Take the pedestrian way out.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;} &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;cfg!(feature = &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;go-nuts&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2f;&#x2f; Let&amp;#39;s get weird.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This is the first time I&#x27;ve used feature flags in one of my own crates. Do they make &amp;quot;Baby&#x27;s First Conditional Compilation&amp;quot; refrigerator magnets? Someone look into it and let me know.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary-1&quot;&gt;Summary&lt;&#x2f;h2&gt;
&lt;p&gt;If you&#x27;ve read this far, you&#x27;re a saint. Hopefully you got something out of it. Like some other nightly features of Rust, procedural macros are a bit of a moving target. I&#x27;ve done my best to make sure everything was up to date, but if you find something that&#x27;s out of date be sure to let me know!&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>About</title>
                <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://tinkering.xyz/about/</link>
                <guid>https://tinkering.xyz/about/</guid>
                <description>&lt;p&gt;I &lt;em&gt;&lt;strong&gt;love&lt;&#x2f;strong&gt;&lt;&#x2f;em&gt; the details. I&#x27;m the kind of person that watches YouTube videos about Unix syscalls in his free time 🤓.&lt;&#x2f;p&gt;
&lt;p&gt;I&#x27;m finishing up the last year of my physics PhD at Purdue University, where I study the details of photosynthesis using ⚡️ultrafast spectroscopy⚡️. Have you burned holes in your business cards with 100 femotosecond laser pulses? I have! I also write the software that glues together the equipment used in my experiments.&lt;&#x2f;p&gt;
&lt;p&gt;I&#x27;ve been writing Python for a little over 5 years. I decided to try Rust for a side project and it was love at first sight ❤️. I&#x27;ve been tinkering away at things in Rust ever since. From there I developed an interest in systems programming.&lt;&#x2f;p&gt;
&lt;p&gt;This blog is made using &lt;a href=&quot;https:&#x2f;&#x2f;www.getzola.org&#x2f;&quot;&gt;Zola&lt;&#x2f;a&gt;, a static site generator written in Rust (&amp;quot;Rewrite It In Rust&amp;quot; can apply to blogs too). The site is hosted on &lt;a href=&quot;https:&#x2f;&#x2f;www.netlify.com&quot;&gt;Netlify&lt;&#x2f;a&gt;, a service I can&#x27;t believe is free.&lt;&#x2f;p&gt;
&lt;p&gt;If you need to reach me, you can find me in the following places:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;zmitchell&quot;&gt;GitHub&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;www.linkedin.com&#x2f;in&#x2f;zmitchell22&quot;&gt;LinkedIn&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;www.twitter.com&#x2f;gluons&quot;&gt;Twitter&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;Email: &lt;a href=&quot;mailto:zmitchell@fastmail.com&quot;&gt;zmitchell@fastmail.com&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
</description>
            </item>
        
    </channel>
</rss>
